name: Publish PyKotor Tools CI/CD

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

env:
  OS_RUNNERS_JSON: '["windows-latest", "ubuntu-latest", "macos-latest"]'
  PYTHON_VERSIONS_JSON: '["3.8", "3.9", "3.10", "3.11", "3.12", "3.13"]'
  ARCHITECTURES_JSON: '["x86", "x64"]'
  UPX_VERSION: "4.2.2"
  USE_UPX: true
  BUILD_BOOTLOADERS: false # Build pyinstaller bootloaders. Pretty much unusable due to AV heuristics.

on:
  #  push:
  workflow_dispatch:
  schedule:
    - cron: "0 6 * * 1" # Runs every Monday at 06:00 UTC

permissions:
  contents: write

jobs:
  detect-tools:
    name: Detect Tools
    runs-on: ubuntu-latest
    outputs:
      tools_matrix: ${{ steps.detect.outputs.tools_matrix }}
    steps:
      - uses: actions/checkout@v4

      - name: Discover tools and compile scripts
        id: detect
        run: |
          python3 << 'PYTHON_SCRIPT'
          import json
          import os
          from pathlib import Path

          tools_dir = Path("Tools")
          tools = []

          def derive_build_name(name: str) -> str:
              lower = name.lower()
              special = {"holocrontoolset": "toolset"}
              return special.get(lower, lower)

          def has_compile_script(build_name: str) -> bool:
              return any(Path(path).exists() for path in [
                  f"compile/compile_{build_name}.ps1",
                  f"compile/compile_{build_name}.sh",
                  f"compile/compile_{build_name}.bat",
              ])

          def has_main_entrypoint(tool_path: Path) -> bool:
              """Check if tool has a __main__.py entrypoint that can be compiled with compile_tool.py"""
              # Look for src/<toolname>/__main__.py pattern
              tool_name_lower = tool_path.name.lower()
              main_path = tool_path / "src" / tool_name_lower / "__main__.py"
              if main_path.exists():
                  return True
              # Also check for alternative patterns (e.g., holocron_ai vs holocronai)
              for src_subdir in (tool_path / "src").iterdir():
                  if src_subdir.is_dir() and (src_subdir / "__main__.py").exists():
                      return True
              return False

          # Check if we're in test mode (limit to one tool)
          test_mode = os.environ.get("ACT_TEST_MODE", "").lower() == "true"
          test_tool = os.environ.get("ACT_TEST_TOOL", "").strip()
          
          if tools_dir.exists():
              for tool_path in sorted(tools_dir.iterdir()):
                  if tool_path.is_dir() and not tool_path.name.startswith("."):
                      # Skip 'tests' directory - it's not a tool
                      if tool_path.name.lower() == "tests":
                          continue
                      
                      # In test mode, only process the specified tool (or first tool if none specified)
                      if test_mode:
                          if test_tool:
                              if tool_path.name.lower() != test_tool.lower() and derive_build_name(tool_path.name) != test_tool.lower():
                                  continue
                          else:
                              # Only process first tool in test mode if no specific tool specified
                              if len(tools) > 0:
                                  continue
                      
                      build_name = derive_build_name(tool_path.name)
                      
                      # Check if tool has a compile script OR can use compile_tool.py
                      if has_compile_script(build_name):
                          # Has explicit compile script
                          tools.append({
                              "tool_dir": tool_path.name,
                              "build_name": build_name,
                              "display_name": tool_path.name,
                              "use_compile_tool": False,
                          })
                      elif has_main_entrypoint(tool_path):
                          # Can use compile_tool.py dynamically
                          tools.append({
                              "tool_dir": tool_path.name,
                              "build_name": build_name,
                              "display_name": tool_path.name,
                              "use_compile_tool": True,
                          })
                      else:
                          print(f"Skipping {tool_path.name}: no compile script found and no __main__.py entrypoint")
                          continue
          else:
              print("❌ Tools directory not found")

          print("Detected tools:")
          for t in tools:
              print(f" - {t['display_name']} (build: {t['build_name']})")

          tools_json = json.dumps(tools)
          print(f"Tools matrix JSON: {tools_json}")
          print(f"Number of tools: {len(tools)}")
          print(f"JSON length: {len(tools_json)}")
          
          # GitHub Actions outputs: use simple single-line format (same as build-pr.yml)
          # fromJson() can parse single-line JSON arrays
          # CRITICAL: Ensure no newlines in the JSON string
          tools_json_clean = tools_json.replace("\n", "").replace("\r", "")
          print(f"Cleaned JSON length: {len(tools_json_clean)}")
          
          with open(os.environ["GITHUB_OUTPUT"], "a") as fh:
              fh.write(f"tools_matrix={tools_json_clean}\n")
          
          print(f"✓ Output written to GITHUB_OUTPUT")
          print(f"  Key: tools_matrix")
          print(f"  Value (first 200 chars): {tools_json_clean[:200]}...")
          
          # Also generate full build matrix for easier fromJSON() parsing
          # This creates a single matrix with all combinations
          import os as os_module
          os_runners = json.loads(os_module.environ.get("OS_RUNNERS_JSON", '["windows-latest", "ubuntu-latest", "macos-latest"]'))
          python_versions = json.loads(os_module.environ.get("PYTHON_VERSIONS_JSON", '["3.8", "3.9", "3.10", "3.11", "3.12", "3.13"]'))
          architectures = json.loads(os_module.environ.get("ARCHITECTURES_JSON", '["x86", "x64"]'))
          
          # Generate full matrix
          full_matrix = []
          for tool in tools:
              for os_name in os_runners:
                  for py_ver in python_versions:
                      for arch in architectures:
                          # Skip unsupported combinations
                          if os_name in ["ubuntu-20.04", "macos-12"] and arch == "x86":
                              continue
                          full_matrix.append({
                              "tool": tool,
                              "os": os_name,
                              "python-version": py_ver,
                              "architecture": arch,
                              "qt_version": "pyqt5"
                          })
          
          full_matrix_json = json.dumps(full_matrix)
          full_matrix_json_clean = full_matrix_json.replace("\n", "").replace("\r", "")
          print(f"Full matrix: {len(full_matrix)} combinations")
          
          with open(os.environ["GITHUB_OUTPUT"], "a") as fh:
              fh.write(f"full_matrix={full_matrix_json_clean}\n")
          
          print(f"✓ Full matrix written to GITHUB_OUTPUT")
          PYTHON_SCRIPT
        env:
          OS_RUNNERS_JSON: ${{ env.OS_RUNNERS_JSON }}
          PYTHON_VERSIONS_JSON: ${{ env.PYTHON_VERSIONS_JSON }}
          ARCHITECTURES_JSON: ${{ env.ARCHITECTURES_JSON }}
  setup:
    runs-on: ubuntu-latest
    outputs:
      os: ${{ steps.set_env.outputs.os }}
      python-version: ${{ steps.set_env.outputs.python-version }}
      architecture: ${{ steps.set_env.outputs.architecture }}
      #qt_version: ${#{ steps.set_env.outputs.qt_version }}

    steps:
      - uses: actions/checkout@v4

      - name: Install PowerShell on non-Windows
        if: runner.os != 'Windows'
        shell: bash
        run: |
          chmod +x ./install_powershell.sh
          bash ./install_powershell.sh

      - name: Set environment variables
        id: set_env
        env:
          ACT_TEST_MODE: ${{ env.ACT_TEST_MODE }}
        run: |
          # In test mode, limit matrix to speed up testing
          $testMode = $env:ACT_TEST_MODE -eq "true"
          
          if ($testMode) {
              $osJson = '["ubuntu-latest"]'
              $pythonJson = '["3.13"]'
              $archJson = '["x64"]'
              Write-Host "Test mode: limiting matrix to ubuntu-latest, Python 3.13, x64"
          } else {
              $osJson = '${{ env.OS_RUNNERS_JSON }}'
              $pythonJson = '${{ env.PYTHON_VERSIONS_JSON }}'
              $archJson = '${{ env.ARCHITECTURES_JSON }}'
          }
          
          # Use simple format (no EOF delimiters) to match detect-tools job format
          # This ensures fromJSON() can parse the outputs correctly
          $singleLineJson = $osJson -replace "`r", "" -replace "`n", ""
          echo "os=$singleLineJson" >> $env:GITHUB_OUTPUT

          $singleLineJson = $pythonJson -replace "`r", "" -replace "`n", ""
          echo "python-version=$singleLineJson" >> $env:GITHUB_OUTPUT

          $singleLineJson = $archJson -replace "`r", "" -replace "`n", ""
          echo "architecture=$singleLineJson" >> $env:GITHUB_OUTPUT
        shell: pwsh

  validate-matrix:
    name: Validate Matrix Outputs
    needs: [setup, detect-tools]
    runs-on: ubuntu-latest
    outputs:
      tools_matrix: ${{ steps.set-outputs.outputs.tools_matrix }}
      os: ${{ steps.set-outputs.outputs.os }}
      python-version: ${{ steps.set-outputs.outputs.python-version }}
      architecture: ${{ steps.set-outputs.outputs.architecture }}
    steps:
      - name: Validate outputs are valid JSON
        run: |
          echo "Validating matrix outputs..."
          
          # Check tools_matrix
          echo "tools_matrix output:"
          echo "${{ needs.detect-tools.outputs.tools_matrix }}"
          
          # Check os, python-version, architecture
          echo "os output:"
          echo "${{ needs.setup.outputs.os }}"
          echo "python-version output:"
          echo "${{ needs.setup.outputs.python-version }}"
          echo "architecture output:"
          echo "${{ needs.setup.outputs.architecture }}"
          
          # Try to parse with fromJSON to verify they're valid
          python3 << 'EOF'
          import json
          import os
          import sys
          
          errors = []
          
          # Get outputs from environment (they're passed as JSON strings)
          tools_matrix = os.environ.get('TOOLS_MATRIX', '')
          os_output = os.environ.get('OS_OUTPUT', '')
          python_output = os.environ.get('PYTHON_OUTPUT', '')
          arch_output = os.environ.get('ARCH_OUTPUT', '')
          
          print(f"tools_matrix length: {len(tools_matrix)}")
          print(f"os_output length: {len(os_output)}")
          print(f"python_output length: {len(python_output)}")
          print(f"arch_output length: {len(arch_output)}")
          
          # Try to parse each
          try:
              tools = json.loads(tools_matrix) if tools_matrix else []
              print(f"✓ tools_matrix is valid JSON: {len(tools)} tools")
              if len(tools) == 0:
                  errors.append("tools_matrix is empty array - this will cause build job to be skipped!")
          except json.JSONDecodeError as e:
              errors.append(f"tools_matrix is invalid JSON: {e}")
          
          try:
              os_list = json.loads(os_output) if os_output else []
              print(f"✓ os is valid JSON: {len(os_list)} items")
              if len(os_list) == 0:
                  errors.append("os is empty array - this will cause build job to be skipped!")
          except json.JSONDecodeError as e:
              errors.append(f"os is invalid JSON: {e}")
          
          try:
              python_list = json.loads(python_output) if python_output else []
              print(f"✓ python-version is valid JSON: {len(python_list)} items")
              if len(python_list) == 0:
                  errors.append("python-version is empty array - this will cause build job to be skipped!")
          except json.JSONDecodeError as e:
              errors.append(f"python-version is invalid JSON: {e}")
          
          try:
              arch_list = json.loads(arch_output) if arch_output else []
              print(f"✓ architecture is valid JSON: {len(arch_list)} items")
              if len(arch_list) == 0:
                  errors.append("architecture is empty array - this will cause build job to be skipped!")
          except json.JSONDecodeError as e:
              errors.append(f"architecture is invalid JSON: {e}")
          
          if errors:
              print("\n❌ ERRORS FOUND:")
              for error in errors:
                  print(f"  - {error}")
              sys.exit(1)
          else:
              print("\n✓ All outputs are valid JSON and non-empty")
          EOF
        env:
          TOOLS_MATRIX: ${{ needs.detect-tools.outputs.tools_matrix }}
          OS_OUTPUT: ${{ needs.setup.outputs.os }}
          PYTHON_OUTPUT: ${{ needs.setup.outputs.python-version }}
          ARCH_OUTPUT: ${{ needs.setup.outputs.architecture }}
      
      - name: Set outputs explicitly
        id: set-outputs
        run: |
          # Explicitly set outputs to ensure they're properly evaluated
          # This helps GitHub Actions properly evaluate fromJSON() in matrix context
          echo "tools_matrix<<EOF" >> $env:GITHUB_OUTPUT
          echo "${{ needs.detect-tools.outputs.tools_matrix }}" >> $env:GITHUB_OUTPUT
          echo "EOF" >> $env:GITHUB_OUTPUT
          
          echo "os<<EOF" >> $env:GITHUB_OUTPUT
          echo "${{ needs.setup.outputs.os }}" >> $env:GITHUB_OUTPUT
          echo "EOF" >> $env:GITHUB_OUTPUT
          
          echo "python-version<<EOF" >> $env:GITHUB_OUTPUT
          echo "${{ needs.setup.outputs.python-version }}" >> $env:GITHUB_OUTPUT
          echo "EOF" >> $env:GITHUB_OUTPUT
          
          echo "architecture<<EOF" >> $env:GITHUB_OUTPUT
          echo "${{ needs.setup.outputs.architecture }}" >> $env:GITHUB_OUTPUT
          echo "EOF" >> $env:GITHUB_OUTPUT
          
          Write-Host "Outputs set successfully"
        shell: pwsh

  build:
    needs: [setup, detect-tools]
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false # Disable automatic cancellation of other jobs
      matrix: ${{ fromJSON(needs.detect-tools.outputs.full_matrix) }}

    steps:
      - uses: actions/checkout@v4

      - name: Install PowerShell on non-Windows
        if: runner.os != 'Windows'
        shell: bash
        run: |
          chmod +x ./install_powershell.sh
          bash ./install_powershell.sh

      - name: Determine Python version string
        id: set-python-version
        run: |
          Add-Content -Path $env:GITHUB_ENV -Value "PYTHON_VERSION=${{ matrix.python-version }}"
        shell: pwsh
        env:
          MATRIX_ARCH: ${{ matrix.architecture }}

      - name: Reset APT sources to default
        if: ${{ runner.os == 'Linux' }}
        run: |
          echo "Resetting APT sources to default Ubuntu repositories"
          sudo rm /etc/apt/sources.list
          echo "deb http://archive.ubuntu.com/ubuntu $(lsb_release -cs) main restricted universe multiverse" | sudo tee -a /etc/apt/sources.list
          echo "deb http://archive.ubuntu.com/ubuntu $(lsb_release -cs)-updates main restricted universe multiverse" | sudo tee -a /etc/apt/sources.list
          echo "deb http://archive.ubuntu.com/ubuntu $(lsb_release -cs)-backports main restricted universe multiverse" | sudo tee -a /etc/apt/sources.list
          echo "deb http://security.ubuntu.com/ubuntu $(lsb_release -cs)-security main restricted universe multiverse" | sudo tee -a /etc/apt/sources.list
          sudo apt-get update -y
        shell: bash

      - name: Add deadsnakes PPA for older Python versions (Linux)
        if: ${{ runner.os == 'Linux' }}
        run: |
          sudo apt-get install -y software-properties-common
          sudo add-apt-repository -y ppa:deadsnakes/ppa
          sudo apt-get update -y
        shell: bash

      - name: Cache UPX
        if: runner.os != 'macOS'
        uses: actions/cache@v4.3.0
        id: cache-upx
        with:
          path: upx-dir
          key: upx-${{ env.UPX_VERSION }}-${{ runner.os }}-${{ matrix.architecture }}
          restore-keys: |
            upx-${{ env.UPX_VERSION }}-${{ runner.os }}-

      - name: Set UPX download URL
        # upx docs express that crashes are happening on ventura and above with upx, don't use on mac.
        if: runner.os != 'macOS'
        id: upx_setup
        run: |
          $build = "no"
          $archiveName = ""
          if ("${{ runner.os }}" -eq "Windows") {
            if ("${{ matrix.architecture }}" -eq "x86") {
              $archiveName = "upx-${{ env.UPX_VERSION }}-win32.zip"
            } else {
              $archiveName = "upx-${{ env.UPX_VERSION }}-win64.zip"
            }
          } elseif ("${{ runner.os }}" -eq "Linux") {
            $archiveName = "upx-${{ env.UPX_VERSION }}-amd64_linux.tar.xz"
          } elseif ("${{ runner.os }}" -eq "macOS") {
            $build = "yes"
            $archiveName = "upx-${{ env.UPX_VERSION }}-src.tar.xz"
          }
          $url = "https://github.com/upx/upx/releases/download/v${{ env.UPX_VERSION }}/$archiveName"

          Add-Content -Path $env:GITHUB_OUTPUT -Value "build=$build"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "url=$url"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "archiveName=$archiveName"
        shell: pwsh

      - name: Download and prepare UPX
        if: runner.os != 'macOS' && steps.cache-upx.outputs.cache-hit != 'true'
        run: |
          $ext = "${{ runner.os }}" -eq "Windows" ? "zip" : "tar.xz"
          $url = "${{ steps.upx_setup.outputs.url }}"
          $archiveName = "${{ steps.upx_setup.outputs.archiveName }}"
          $outputPath = "upx-dir"

          # Use Invoke-WebRequest or curl depending on the OS
          if ("${{ runner.os }}" -eq "Windows") {
            Invoke-WebRequest -Uri $url -OutFile $archiveName
          } elseif ("${{ runner.os }}" -eq "Linux") {
            curl -L $url -o $archiveName
          }

          New-Item -ItemType Directory -Force -Path "upx-dir" -ErrorAction SilentlyContinue
          if ("${{ runner.os }}" -ne "macOS") {
            if ($ext -eq "zip") {
              $fileNameWithoutExtension = [System.IO.Path]::GetFileNameWithoutExtension($archiveName)
              Expand-Archive -Path $archiveName -DestinationPath "temp_folder_upx"
              if (-not (Test-Path -Path "upx-dir")) {
                  New-Item -ItemType Directory -Path "upx-dir"
              }
              Get-ChildItem -LiteralPath "temp_folder_upx/$fileNameWithoutExtension" -Recurse | Move-Item -Destination "upx-dir"
              Remove-Item "temp_folder_upx" -Recurse -Force -ErrorAction SilentlyContinue
            } else {
              tar -xvf $archiveName --strip-components=1 -C "upx-dir"
            }

            Remove-Item $archiveName # Clean up downloaded archive
          }
        shell: pwsh

      - name: Set UPX directory path
        if: runner.os != 'macOS'
        id: upx_dir
        run: |
          $upx_dir = "./upx-dir"
          $upx_dir = $([System.IO.Path]::GetFullPath('./upx-dir'))
          Dir -Recurse $upx_dir | Get-Childitem
          echo "UPX_DIR=$upx_dir" | Out-File -FilePath $env:GITHUB_ENV -Append
          Write-Output "UPX_DIR set to '$upx_dir'"
        shell: pwsh

      - name: Install Visual Studio 2015 C++ Redistributable
        if: runner.os == 'Windows'
        run: |
          $url = "${{ matrix.vc_redist2015 }}"
          $output = "vc_redist.exe"
          Invoke-WebRequest -Uri $url -OutFile $output
          Start-Process $output -ArgumentList '/install', '/quiet', '/norestart' -Wait
          Remove-Item -Path $output
          #choco install vcredist2015 -y
        shell: pwsh

      - name: Install Visual Studio 2019 C++ Redistributable
        if: runner.os == 'Windows'
        run: |
          $url = "${{ matrix.vc_redist2019 }}"
          $output = "vc_redist.exe"
          Invoke-WebRequest -Uri $url -OutFile $output
          Start-Process $output -ArgumentList '/install', '/quiet', '/norestart' -Wait
          Remove-Item -Path $output
          #choco install vcredist2019 -y
        shell: pwsh

      - name: Install Visual Studio latest C++ Redistributable
        if: runner.os == 'Windows'
        run: |
          $url = "${{ matrix.vc_redist-latest }}"
          $output = "vc_redist.exe"
          Invoke-WebRequest -Uri $url -OutFile $output
          Start-Process $output -ArgumentList '/install', '/quiet', '/norestart' -Wait
          Remove-Item -Path $output
        shell: pwsh

      - name: Locate compile and dependency scripts
        id: locate-scripts
        shell: pwsh
        run: |
          # Matrix now contains tool object directly
          $buildName = "${{ matrix.tool.build_name }}"
          $toolDir = "${{ matrix.tool.tool_dir }}"
          $useCompileTool = "${{ matrix.tool.use_compile_tool }}" -eq "True"
          
          $compileScript = ""
          $depsScript = ""
          
          if ($useCompileTool) {
            # Use compile_tool.py dynamically
            $compileScript = "compile/compile_tool.py"
            # Check for deps script, but it's optional
            $depsCandidates = @("compile/deps_${buildName}.ps1","compile/deps_${buildName}.sh","compile/deps_${buildName}.bat","compile/deps_tool.ps1","compile/deps_tool.sh","compile/deps_tool.bat")
            foreach ($d in $depsCandidates) { if (Test-Path $d) { $depsScript = $d; break } }
          } else {
            # Use explicit compile script
            $compileCandidates = @("compile/compile_${buildName}.ps1","compile/compile_${buildName}.sh","compile/compile_${buildName}.bat")
            $depsCandidates = @("compile/deps_${buildName}.ps1","compile/deps_${buildName}.sh","compile/deps_${buildName}.bat")
            foreach ($c in $compileCandidates) { if (Test-Path $c) { $compileScript = $c; break } }
            foreach ($d in $depsCandidates) { if (Test-Path $d) { $depsScript = $d; break } }
          }
          
          if (-not $compileScript -or -not (Test-Path $compileScript)) { 
            Write-Error "Compile script not found for $buildName (use_compile_tool=$useCompileTool)"; 
            exit 1 
          }
          
          echo "compile_script=$compileScript" >> $env:GITHUB_OUTPUT
          echo "deps_script=$depsScript" >> $env:GITHUB_OUTPUT
          echo "use_compile_tool=$useCompileTool" >> $env:GITHUB_OUTPUT
          echo "tool_dir=$toolDir" >> $env:GITHUB_OUTPUT
          echo "Using compile script $compileScript"
          if ($depsScript) { echo "Using deps script $depsScript" } else { echo "No deps script found" }

      - name: Pre-install Python packages (Linux workaround)
        if: ${{ runner.os == 'Linux' }}
        shell: bash
        run: |
          # Workaround: Pre-install Python without pip package (python3.X-pip doesn't exist in deadsnakes PPA)
          # This prevents install_python_venv.ps1 from failing and prompting for input
          PYTHON_VERSION="${{ matrix.python-version }}"
          PYTHON_MAJOR_MINOR=$(echo $PYTHON_VERSION | cut -d. -f1,2)
          
          echo "Adding deadsnakes PPA for Python $PYTHON_VERSION..."
          sudo apt-get update -qq
          sudo apt-get install -y software-properties-common
          sudo add-apt-repository -y ppa:deadsnakes/ppa || true
          sudo apt-get update -qq
          
          echo "Pre-installing Python $PYTHON_VERSION packages (without pip package)..."
          sudo apt-get install -y \
            python${PYTHON_MAJOR_MINOR} \
            python${PYTHON_MAJOR_MINOR}-dev \
            python${PYTHON_MAJOR_MINOR}-venv \
            libpython${PYTHON_MAJOR_MINOR}-dev || true
          
          # Verify Python is available
          python${PYTHON_MAJOR_MINOR} --version || (echo "Failed to install Python $PYTHON_VERSION" && exit 1)

      - name: Cache pip packages (Linux/macOS)
        if: runner.os != 'Windows'
        uses: actions/cache@v4.3.0
        id: cache-pip-unix
        with:
          path: |
            ~/.cache/pip
            ~/Library/Caches/pip
          key: pip-${{ runner.os }}-${{ matrix.python-version }}-${{ matrix.architecture }}-${{ hashFiles('**/requirements.txt', '**/pyproject.toml', '**/setup.py') }}
          restore-keys: |
            pip-${{ runner.os }}-${{ matrix.python-version }}-${{ matrix.architecture }}-
            pip-${{ runner.os }}-${{ matrix.python-version }}-
            pip-${{ runner.os }}-

      - name: Get Windows pip cache path
        if: runner.os == 'Windows'
        id: pip-cache-path
        shell: pwsh
        run: |
          $pipCache = "$env:LOCALAPPDATA\pip\Cache"
          echo "path=$pipCache" >> $env:GITHUB_OUTPUT

      - name: Cache pip packages (Windows)
        if: runner.os == 'Windows'
        uses: actions/cache@v4.3.0
        id: cache-pip-windows
        with:
          path: ${{ steps.pip-cache-path.outputs.path }}
          key: pip-${{ runner.os }}-${{ matrix.python-version }}-${{ matrix.architecture }}-${{ hashFiles('**/requirements.txt', '**/pyproject.toml', '**/setup.py') }}
          restore-keys: |
            pip-${{ runner.os }}-${{ matrix.python-version }}-${{ matrix.architecture }}-
            pip-${{ runner.os }}-${{ matrix.python-version }}-
            pip-${{ runner.os }}-

      - name: Create virtual environment
        shell: pwsh
        env:
          MATRIX_ARCH: ${{ matrix.architecture }}
        run: |
          $ErrorActionPreference = "Stop"
          $buildName = "${{ matrix.tool.build_name }}"
          $venvName = ".venv_${buildName}_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}"
          
          # Set LD_LIBRARY_PATH for Linux (needed for some Python installations)
          if ("${{ runner.os }}" -eq "Linux") {
            $env:LD_LIBRARY_PATH = "/usr/local/lib:$env:LD_LIBRARY_PATH"
          }
          
          try {
            Write-Host "Calling install_python_venv.ps1 with venv_name=$venvName and force_python_version=${{ matrix.python-version }}"
            Write-Host "OS: ${{ runner.os }}, Architecture: ${{ matrix.architecture }}, Python version: ${{ matrix.python-version }}"
            
            # Source the script to run it in current session (allows it to set variables)
            # -noprompt flag ensures non-interactive mode (no prompts)
            . ./install_python_venv.ps1 -noprompt -venv_name $venvName -force_python_version ${{ matrix.python-version }}
            
            # Check if script set pythonExePath variable
            if (-not (Test-Path variable:pythonExePath) -or -not $pythonExePath) {
              Write-Host "Warning: install_python_venv.ps1 did not set pythonExePath variable"
              Write-Host "Checking for venv Python executable directly..."
              
              # Try to find Python in the venv
              $venvPath = $venvName
              if ("${{ runner.os }}" -eq "Windows") {
                $pythonExePath = Join-Path $venvPath "Scripts\python.exe"
              } else {
                $pythonExePath = Join-Path $venvPath "bin\python"
              }
              
              if (-not (Test-Path $pythonExePath)) {
                Write-Error "Python executable not found at expected path: $pythonExePath"
                Write-Host "Listing venv directory contents:"
                if (Test-Path $venvPath) {
                  Get-ChildItem -Path $venvPath -Recurse -Depth 2 | Select-Object FullName
                } else {
                  Write-Error "Venv directory does not exist: $venvPath"
                }
                exit 1
              }
            }
            
            Write-Host "Python executable path: $pythonExePath"
            
            # Verify Python exists and works
            & $pythonExePath --version
            if ($LASTEXITCODE -ne 0) {
              Write-Error "Python executable at $pythonExePath is not working"
              exit 1
            }
            
            # On Linux and macOS, ensure pip is available (bootstrap if needed)
            if ("${{ runner.os }}" -eq "Linux" -or "${{ runner.os }}" -eq "macOS") {
              # Try to bootstrap pip if it's not available
              $pipCheck = & $pythonExePath -m pip --version 2>&1
              if ($LASTEXITCODE -ne 0) {
                Write-Host "Pip not available, bootstrapping with ensurepip..."
                & $pythonExePath -m ensurepip --upgrade --default-pip
                if ($LASTEXITCODE -ne 0) {
                  Write-Error "Failed to bootstrap pip"
                  exit 1
                }
              }
            }
            
            & $pythonExePath -m pip install --upgrade pip
            if ($LASTEXITCODE -ne 0) {
              Write-Error "Failed to upgrade pip"
              exit 1
            }
            
            if ("${{ runner.os }}" -eq "Windows") {
              if ("${{ matrix.python-version }}" -eq "3.12" -or "${{ matrix.python-version }}" -eq "3.11") {
                & $pythonExePath -m pip install "pyinstaller==5.13.2" --prefer-binary
              } else {
                & $pythonExePath -m pip install "pyinstaller==5.4" --prefer-binary
              }
            } else {
              & $pythonExePath -m pip install pyinstaller -U --prefer-binary
            }
            
            if ($LASTEXITCODE -ne 0) {
              Write-Error "Failed to install pyinstaller"
              exit 1
            }
          } catch {
            Write-Host -ForegroundColor Red "Error creating virtual environment: $($_.Exception.Message)"
            Write-Host -ForegroundColor Red "Stack trace: $($_.ScriptStackTrace)"
            exit 1
          }

      - name: Install tool dependencies
        if: ${{ steps.locate-scripts.outputs.deps_script != '' }}
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $script = "${{ steps.locate-scripts.outputs.deps_script }}"
          $buildName = "${{ matrix.tool.build_name }}"
          $venvName = ".venv_${buildName}_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}"
          
          # Ensure Python path is available if set by install_python_venv.ps1
          if ($env:pythonExePath) {
            $pythonDir = Split-Path -Parent $env:pythonExePath
            if ("${{ runner.os }}" -eq "Windows") {
              $env:PATH = "$pythonDir;$env:PATH"
            } else {
              $env:PATH = "${pythonDir}:$env:PATH"
            }
          } elseif (Test-Path variable:pythonExePath) {
            $pythonDir = Split-Path -Parent $pythonExePath
            if ("${{ runner.os }}" -eq "Windows") {
              $env:PATH = "$pythonDir;$env:PATH"
            } else {
              $env:PATH = "${pythonDir}:$env:PATH"
            }
          }
          
          Write-Host "Running deps script $script"
          Write-Host "Venv name: $venvName"
          
          try {
            if ($script.EndsWith(".ps1")) {
              . "./$script" -noprompt -venv_name $venvName
            } elseif ($script.EndsWith(".sh")) {
              bash "./$script" -noprompt -venv_name $venvName
            } elseif ($script.EndsWith(".bat")) {
              cmd /c ".\\$script -noprompt -venv_name $venvName"
            } else {
              Write-Error "Unknown deps script type: $script"
              exit 1
            }
            
            if ($LASTEXITCODE -ne 0) {
              Write-Error "Deps script failed with exit code $LASTEXITCODE"
              exit $LASTEXITCODE
            }
          } catch {
            Write-Host -ForegroundColor Red "Error running deps script: $($_.Exception.Message)"
            Write-Host -ForegroundColor Red "Stack trace: $($_.ScriptStackTrace)"
            exit 1
          }

      - name: Compile tool
        shell: pwsh
        env:
          MATRIX_ARCH: ${{ matrix.architecture }}
        run: |
          $ErrorActionPreference = "Stop"
          $compile = "${{ steps.locate-scripts.outputs.compile_script }}"
          $buildName = "${{ matrix.tool.build_name }}"
          $venvName = ".venv_${buildName}_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}"
          $upxDir = $env:UPX_DIR
          $env:PYTHONOPTIMIZE = "1"
          
          # Set LD_LIBRARY_PATH for Linux
          if ("${{ runner.os }}" -eq "Linux") {
            $env:LD_LIBRARY_PATH = "/usr/local/lib:$env:LD_LIBRARY_PATH"
          }
          
          # Ensure Python path is available if set by install_python_venv.ps1
          if ($env:pythonExePath) {
            $pythonDir = Split-Path -Parent $env:pythonExePath
            if ("${{ runner.os }}" -eq "Windows") {
              $env:PATH = "$pythonDir;$env:PATH"
            } else {
              $env:PATH = "${pythonDir}:$env:PATH"
            }
          } elseif (Test-Path variable:pythonExePath) {
            $pythonDir = Split-Path -Parent $pythonExePath
            if ("${{ runner.os }}" -eq "Windows") {
              $env:PATH = "$pythonDir;$env:PATH"
            } else {
              $env:PATH = "${pythonDir}:$env:PATH"
            }
          }
          
          Write-Host "Using compile script $compile"
          Write-Host "Venv name: $venvName"
          Write-Host "UPX directory: $upxDir"
          
          $useCompileTool = "${{ steps.locate-scripts.outputs.use_compile_tool }}" -eq "True"
          $toolDir = "${{ steps.locate-scripts.outputs.tool_dir }}"
          
          try {
            if ($useCompileTool -and $compile.EndsWith(".py")) {
              # Use compile_tool.py dynamically
              $toolPath = "Tools/$toolDir"
              $entrypoint = ""
              
              # Find the entrypoint (src/<toolname>/__main__.py)
              $toolNameLower = $toolDir.ToLower()
              $possibleEntrypoints = @(
                "$toolNameLower/__main__.py",
                "$toolDir/__main__.py"
              )
              
              foreach ($ep in $possibleEntrypoints) {
                $epPath = Join-Path $toolPath "src/$ep"
                if (Test-Path $epPath) {
                  $entrypoint = $ep
                  break
                }
              }
              
              # If not found, search for any __main__.py in src subdirectories
              if (-not $entrypoint) {
                $srcDir = Join-Path $toolPath "src"
                if (Test-Path $srcDir) {
                  $mainFiles = Get-ChildItem -Path $srcDir -Recurse -Filter "__main__.py" -ErrorAction SilentlyContinue
                  if ($mainFiles) {
                    $relativePath = $mainFiles[0].FullName.Replace((Resolve-Path $srcDir).Path + [System.IO.Path]::DirectorySeparatorChar, "")
                    $entrypoint = $relativePath.Replace([System.IO.Path]::DirectorySeparatorChar, "/")
                  }
                }
              }
              
              if (-not $entrypoint) {
                Write-Error "Could not find __main__.py entrypoint for tool $toolDir"
                exit 1
              }
              
              Write-Host "Using compile_tool.py with entrypoint: $entrypoint"
              
              # Build compile_tool.py command
              $pythonExe = if (Test-Path variable:pythonExePath) { $pythonExePath } else { "python" }
              $compileArgs = @(
                "$compile",
                "--tool-path", $toolPath,
                "--entrypoint", $entrypoint,
                "--venv-name", $venvName,
                "--noprompt"
              )
              
              if ($upxDir) {
                $compileArgs += @("--upx-dir", $upxDir)
              }
              
              & $pythonExe $compileArgs
            } elseif ($compile.EndsWith(".ps1")) {
              if ($upxDir) {
                . "./$compile" -noprompt -venv_name $venvName -upx_dir $upxDir
              } else {
                . "./$compile" -noprompt -venv_name $venvName
              }
            } elseif ($compile.EndsWith(".sh")) {
              if ($upxDir) {
                $env:UPX_DIR = $upxDir
              }
              bash "./$compile" -noprompt -venv_name $venvName
            } elseif ($compile.EndsWith(".bat")) {
              if ($upxDir) {
                $env:UPX_DIR = $upxDir
              }
              cmd /c ".\\$compile -noprompt -venv_name $venvName"
            } else {
              Write-Error "Unknown compile script type: $compile"
              exit 1
            }
            
            if ($LASTEXITCODE -ne 0) {
              Write-Error "Compilation failed with exit code $LASTEXITCODE"
              exit $LASTEXITCODE
            }
          } catch {
            Write-Host -ForegroundColor Red "Error during compilation: $($_.Exception.Message)"
            Write-Host -ForegroundColor Red "Stack trace: $($_.ScriptStackTrace)"
            exit 1
          }

      - name: Upload compiled binaries attempt 1
        if: ${{ success() || failure() }}
        id: upload_attempt_1
        uses: actions/upload-artifact@v4
        with:
          name: publish_${{ matrix.tool.build_name }}_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
          path: ./dist/**
          retention-days: 90
        continue-on-error: true

      - name: Upload compiled binaries attempt 2
        id: upload_attempt_2
        if: ${{ (success() || failure()) && steps.upload_attempt_1.outcome == 'failure' }}
        uses: actions/upload-artifact@v4
        with:
          name: publish_${{ matrix.tool.build_name }}_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
          path: ./dist/**
          retention-days: 90
        continue-on-error: true

      - name: Upload compiled binaries attempt 3
        id: upload_attempt_3
        if: ${{ (success() || failure()) && steps.upload_attempt_2.outcome == 'failure' }}
        uses: actions/upload-artifact@v4
        with:
          name: publish_${{ matrix.tool.build_name }}_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
          path: ./dist/**
          retention-days: 90
        continue-on-error: true

      - name: Upload compiled binaries attempt 4
        id: upload_attempt_4
        if: ${{ (success() || failure()) && steps.upload_attempt_3.outcome == 'failure' }}
        uses: actions/upload-artifact@v4
        with:
          name: publish_${{ matrix.tool.build_name }}_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
          path: ./dist/**
          retention-days: 90
        continue-on-error: true

      - name: Upload compiled binaries attempt 5
        id: upload_attempt_5
        if: ${{ (success() || failure()) && steps.upload_attempt_4.outcome == 'failure' }}
        uses: actions/upload-artifact@v4
        with:
          name: publish_${{ matrix.tool.build_name }}_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}
          path: ./dist/**
          retention-days: 90

      - name: Run tests for compiled tool
        shell: pwsh
        env:
          MATRIX_ARCH: ${{ matrix.architecture }}
        run: |
          $ErrorActionPreference = "Stop"
          $buildName = "${{ matrix.tool.build_name }}"
          $venvName = ".venv_${buildName}_${{ matrix.os }}_${{ matrix.python-version }}_${{ matrix.architecture }}"
          $toolDir = "Tools/${{ matrix.tool.tool_dir }}"
          
          # Set LD_LIBRARY_PATH for Linux
          if ("${{ runner.os }}" -eq "Linux") {
            $env:LD_LIBRARY_PATH = "/usr/local/lib:$env:LD_LIBRARY_PATH"
          }
          
          # Ensure Python path is available if set by install_python_venv.ps1
          if ($env:pythonExePath) {
            $pythonDir = Split-Path -Parent $env:pythonExePath
            if ("${{ runner.os }}" -eq "Windows") {
              $env:PATH = "$pythonDir;$env:PATH"
            } else {
              $env:PATH = "${pythonDir}:$env:PATH"
            }
          } elseif (Test-Path variable:pythonExePath) {
            $pythonDir = Split-Path -Parent $pythonExePath
            if ("${{ runner.os }}" -eq "Windows") {
              $env:PATH = "$pythonDir;$env:PATH"
            } else {
              $env:PATH = "${pythonDir}:$env:PATH"
            }
          }
          
          # Find Python executable
          $venvPath = $venvName
          if ("${{ runner.os }}" -eq "Windows") {
            $pythonExePath = Join-Path $venvPath "Scripts\python.exe"
          } else {
            $pythonExePath = Join-Path $venvPath "bin\python"
          }
          
          if (-not (Test-Path $pythonExePath)) {
            Write-Host "Python executable not found at $pythonExePath, skipping tests"
            exit 0
          }
          
          Write-Host "Running tests for ${{ matrix.tool.display_name }}"
          Write-Host "Tool directory: $toolDir"
          Write-Host "Python executable: $pythonExePath"
          
          # Check if tests directory exists
          $testsPath = Join-Path $toolDir "tests"
          if (-not (Test-Path $testsPath)) {
            Write-Host "No tests directory found at $testsPath, skipping tests"
            exit 0
          }
          
          # Install test dependencies if needed
          $pyprojectPath = Join-Path $toolDir "pyproject.toml"
          if (Test-Path $pyprojectPath) {
            Write-Host "Installing test dependencies from pyproject.toml..."
            & $pythonExePath -m pip install -e "$toolDir[dev]" --quiet 2>&1 | Out-Null
          }
          
          # Install pytest-timeout if available
          & $pythonExePath -m pip install pytest-timeout --quiet 2>&1 | Out-Null
          
          # Run tests with timeout (2 minutes for individual tests)
          Write-Host "Running pytest tests..."
          try {
            $pytestArgs = @("$testsPath", "-v", "--tb=short")
            
            # Add timeout if pytest-timeout is available
            $timeoutCheck = & $pythonExePath -m pytest --help 2>&1 | Select-String "timeout"
            if ($timeoutCheck) {
              $pytestArgs += @("--timeout=120", "--timeout-method=thread")
            }
            
            if ("${{ runner.os }}" -eq "Linux") {
              # Use xvfb for GUI tests on Linux if available
              if (Get-Command xvfb-run -ErrorAction SilentlyContinue) {
                Write-Host "Using xvfb-run for GUI tests..."
                xvfb-run -a & $pythonExePath -m pytest $pytestArgs
              } else {
                & $pythonExePath -m pytest $pytestArgs
              }
            } else {
              & $pythonExePath -m pytest $pytestArgs
            }
            
            if ($LASTEXITCODE -ne 0) {
              Write-Host -ForegroundColor Yellow "Tests completed with exit code $LASTEXITCODE (some tests may have failed)"
              # Don't fail the build if tests fail, but report it
            } else {
              Write-Host -ForegroundColor Green "All tests passed!"
            }
          } catch {
            Write-Host -ForegroundColor Yellow "Error running tests: $($_.Exception.Message)"
            Write-Host "Continuing despite test errors..."
          }

  package: # The goal of this job is to repackage by toolname, rather than all tools by os_pyversion_arch
    needs: build # do not start this job until all 'build' jobs complete
    if: ${{ always() && (needs.build.result == 'success' || needs.build.result == 'failure') }}
    runs-on: ubuntu-latest
    outputs:
      filesToArchive: ${{ steps.set-matrix.outputs.matrixJson }}
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: published_workflow_builds/
          pattern: publish_*
          if-no-files-found: warn

      - name: Re-package artifacts by Python version and architecture
        shell: pwsh
        run: |
          $here_dirpath = (Get-Location)
          Write-Output "here: '$here_dirpath'"
          $packagedArtifactsPath = Join-Path -Path $here_dirpath -ChildPath "packaged_artifacts"
          New-Item -ItemType Directory -Force -Path $packagedArtifactsPath

          # Check if artifacts directory exists
          $artifactsDir = "published_workflow_builds"
          if (-not (Test-Path $artifactsDir)) {
              Write-Host "No artifacts directory found - creating empty directory" -ForegroundColor Yellow
              New-Item -ItemType Directory -Force -Path $artifactsDir
          }
          
          # Check if there are any artifacts
          $artifactCount = (Get-ChildItem -Path $artifactsDir -Filter "publish_*" -ErrorAction SilentlyContinue | Measure-Object).Count
          if ($artifactCount -eq 0) {
              Write-Host "No build artifacts found - this may indicate all build jobs failed" -ForegroundColor Yellow
              Write-Host "Creating empty artifact-names.txt to allow workflow to continue" -ForegroundColor Yellow
              @() | Out-File -FilePath "artifact-names.txt" -Encoding UTF8
              exit 0
          }

          # Navigate to the directory with downloaded artifacts
          Set-Location -Path $artifactsDir

          $artifactNames = New-Object 'System.Collections.Generic.HashSet[string]'
          # Iterate through each tool_os_pythonversion_arch folder.
          Get-ChildItem -Filter "publish_*" | ForEach-Object {
            $matrixPackagePath = $_.FullName
            Write-Output "Found matrix package '$matrixPackagePath'"
            $toolName, $os, $pythonVersion, $architecture = $_.BaseName -replace '^publish_', '' -split '_',4

            $shortOsName = $os
            if ($os -eq "ubuntu-20.04" -or $os -eq "ubuntu-22.04" -or $os -eq "ubuntu-latest") {
              $shortOsName = "Linux"
            } elseif ($os -eq "macos-11" -or $os -eq "macos-12" -or $os -eq "macos-latest") {
              $shortOsName = "Mac"
            } elseif ($os -eq "windows-latest" -or $os -eq "windows-2022") {
              $shortOsName = "Win"
            }

            # Iterate through each tool in the folder
            Get-ChildItem -LiteralPath $matrixPackagePath | ForEach-Object {
              $toolExePath = $_.FullName
              $toolFileName = $_.Name
              $fileBaseName = [IO.Path]::GetFileNameWithoutExtension($_.Name)
              $fileExtension = $_.Extension

              $outerArchiveName = "${toolName}_$fileBaseName`_$pythonVersion"
              $outerZipPath = Join-Path -Path $packagedArtifactsPath -ChildPath $outerArchiveName
              $osSpecificArchiveName = "${toolName}_$fileBaseName`_$shortOsName-$architecture"
              $osSpecificArchivePath = Join-Path -Path $outerZipPath -ChildPath $osSpecificArchiveName

              Write-Output "   ToolFileName: '$toolFileName'"
              Write-Output "   Tool original filepath: '$toolExePath'"
              Write-Output "outerArchiveName: '$outerArchiveName'"
              Write-Output " - osSpecificArchiveName: '$osSpecificArchiveName'"
              Write-Output "outerZipPath: '$outerZipPath'"
              Write-Output " - osSpecificArchivePath: '$osSpecificArchivePath'"

              New-Item -ItemType Directory -Force -Path $outerZipPath
              chmod 777 -R $toolExePath
              $toolExeParentDirPath = Split-Path -Parent $toolExePath
              Write-Output "Creating archive for '$toolFileName' at '$toolExeParentDirPath'..."

              Write-Output ("Push-Location to start in '$toolExeParentDirPath' (originally at '$(Get-Location)')")
              Push-Location -Path $toolExeParentDirPath
              # Archive the tool by os identifier.
              if ((-not $fileExtension) -or (-not $fileExtension.Trim()) -or ($fileExtension.ToLower().Trim() -eq ".app")) {
                $osSpecificArchivePath = "$osSpecificArchivePath.tar.gz"
                if (Test-Path $toolExePath -PathType Container -ErrorAction SilentlyContinue) {  # It's a directory
                  tar -czf "$osSpecificArchivePath" -C "$toolExePath" .
                } else {  # It's a file
                  tar -czf "$osSpecificArchivePath" -C "$toolExeParentDirPath" $toolFileName
                }
              } else {
                $osSpecificArchivePath = "$osSpecificArchivePath.zip"
                zip -r -9 "$osSpecificArchivePath" $toolFileName
              }
              Pop-Location
              Write-Output ("Pop-Location to return to $(Get-Location) (was pushed to '$toolExeParentDirPath')")

              Write-Output "Compressed archive saved to '$osSpecificArchivePath'"
              chmod 777 -R "$osSpecificArchivePath"

              $artifactNames.Add($outerArchiveName)
            }
          }

          # Save artifact names to a file
          $artifactNames | Out-File -FilePath "../artifact-names.txt" -Encoding UTF8

          # use for debug
          # Get-ChildItem -Force | ForEach-Object {
          #   $size = if ($_.PSIsContainer) { "N/A" } else { $_.Length }
          #   $attrs = $_.Attributes.ToString() -replace 'ReadOnly', 'RO' -replace 'Hidden', 'H' -replace 'System', 'S' -replace 'Archive', 'A' -replace 'Directory', 'D' -replace ', ', '|'
          #   [PSCustomObject]@{
          #       Name = $_.Name
          #       Size = $size
          #       Attributes = $attrs
          #   }
          # } | Format-Table -AutoSize

          # Navigate back to the root of the workspace
          Set-Location -Path "../"

      - name: Generate matrix for uploading
        if: ${{ success() || failure() }}
        id: set-matrix
        shell: pwsh
        run: |
          $artifactNames = Get-Content 'artifact-names.txt' -ReadCount 0

          # Initialize an array to hold the artifact names directly
          $matrixArray = @()

          foreach ($name in $artifactNames) {
            if (-not [string]::IsNullOrEmpty($name)) {
              Write-Host "Processing artifact name: $name"
              # Trim the name and add directly to the array
              $matrixArray += $name.trim()
            }
          }

          # Convert the array directly to JSON
          $jsonMatrix = $matrixArray | ConvertTo-Json -Depth 5 -Compress

          # Use a single line of JSON for the matrix to avoid issues
          $singleLineJsonMatrix = $jsonMatrix -replace "`r", ""
          $singleLineJsonMatrix = $singleLineJsonMatrix -replace "`n", ""
          Write-Host "Matrix JSON:"
          Write-Host $singleLineJsonMatrix

          echo "matrixJson<<EOF" >> $env:GITHUB_OUTPUT
          echo $singleLineJsonMatrix >> $env:GITHUB_OUTPUT
          echo "EOF" >> $env:GITHUB_OUTPUT

      - name: Upload all repackages for next job
        if: ${{ success() || failure() }}
        uses: actions/upload-artifact@v4
        with:
          name: all_tool_dists_onearchive
          path: packaged_artifacts/**
          retention-days: 1 # only used for the next job.
          compression-level: 0

  upload:
    needs: package
    if: ${{ success() || failure() }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        artifactb: ${{ fromJson(needs.package.outputs.filesToArchive) }}
    steps:
      - name: Download repackages from package job
        if: ${{ success() || failure() }}
        uses: actions/download-artifact@v4
        with:
          path: all_tool_dists_onearchive
          pattern: all_tool_dists*

      - name: Upload re-packaged artifact
        if: ${{ success() || failure() }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifactb }}
          path: all_tool_dists_onearchive/all_tool_dists_onearchive/${{ matrix.artifactb }}
          compression-level: 9
          if-no-files-found: error
