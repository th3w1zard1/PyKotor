name: Create Release

on:
  workflow_dispatch:
    inputs:
      tool:
        description: 'Tool name (matches tool directory or build name; e.g., toolset, holopatcher, kotordiff)'
        required: true
        type: string
      version:
        description: 'Version to release (e.g., 3.1.3)'
        required: true
      release_notes:
        description: 'Release notes (optional, will use default if empty)'
        required: false
        default: ''
      skip_version_bump:
        description: 'Skip version bump (version already updated in config)'
        required: false
        default: false
        type: boolean

concurrency:
  group: create-release-${{ github.event.inputs.tool }}
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  validate:
    name: Validate Release Parameters
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ steps.config.outputs.tag_name }}
      config_file: ${{ steps.config.outputs.config_file }}
      display_name: ${{ steps.config.outputs.display_name }}
      current_version: ${{ steps.config.outputs.current_version }}
      version_key: ${{ steps.config.outputs.version_key }}
      tool_dir: ${{ steps.config.outputs.tool_dir }}
      build_name: ${{ steps.config.outputs.build_name }}
    steps:
      - uses: actions/checkout@v4

      - name: Detect tool and validate version
        id: config
        run: |
          python3 << 'PYTHON_SCRIPT'
          import json
          import os
          import re
          import sys
          from pathlib import Path

          version = os.environ["INPUT_VERSION"].strip()
          tool_input = os.environ["INPUT_TOOL"].strip().lower()

          print(f"=== Validating version {version} for {tool_input} ===")

          if not re.fullmatch(r"[0-9]+\.[0-9]+(\.[0-9]+)?(-[A-Za-z0-9.]+)?", version):
            print(f"‚ùå Invalid version format: {version}")
            print("   Expected: MAJOR.MINOR[.PATCH][-suffix]")
            sys.exit(1)
          print("‚úì Version format is valid")

          tools_dir = Path("Tools")
          if not tools_dir.exists():
            print("‚ùå Tools directory not found")
            sys.exit(1)

          def derive_build_name(tool_dir_name: str) -> str:
            name_lower = tool_dir_name.lower()
            special_mappings = {
              "holocrontoolset": "toolset",
            }
            return special_mappings.get(name_lower, name_lower)

          def find_config_file(tool_dir: Path, tool_name_lower: str) -> Path | None:
            src_dir = tool_dir / "src" / tool_name_lower
            config_py = src_dir / "config.py"
            if config_py.exists():
              return config_py
            config_info_py = src_dir / "config" / "config_info.py"
            if config_info_py.exists():
              return config_info_py
            main_py = src_dir / "__main__.py"
            if main_py.exists():
              content = main_py.read_text()
              if "CURRENT_VERSION" in content:
                return main_py
            init_py = src_dir / "__init__.py"
            if init_py.exists():
              content = init_py.read_text()
              if "__version__" in content:
                return init_py
            return None

          tools = []
          for tool_path in sorted(tools_dir.iterdir()):
            if tool_path.is_dir() and not tool_path.name.startswith("."):
              t_lower = tool_path.name.lower()
              build_name = derive_build_name(tool_path.name)
              config_path = find_config_file(tool_path, t_lower)
              tools.append(
                {
                  "tool_dir": tool_path.name,
                  "tool_dir_lower": t_lower,
                  "build_name": build_name,
                  "config_file": str(config_path) if config_path else "",
                  "display_name": tool_path.name,
                }
              )

          matching = [
            t for t in tools
            if t["build_name"] == tool_input or t["tool_dir_lower"] == tool_input
          ]

          if not matching:
            print("‚ùå Unknown tool selection.")
            if tools:
              print("Available tools (build_name -> dir):")
              for t in tools:
                print(f"  - {t['build_name']} -> Tools/{t['tool_dir']}")
            sys.exit(1)

          tool = matching[0]
          config_path_str = tool["config_file"]

          if not config_path_str:
            print(f"‚ùå Could not find a config/version file for {tool['display_name']}")
            sys.exit(1)

          config_path = Path(config_path_str)
          if not config_path.exists():
            print(f"‚ùå Config file not found: {config_path}")
            sys.exit(1)

          content = config_path.read_text()
          version_key = None
          current = "unknown"

          if '"currentVersion":' in content:
            version_key = "currentVersion"
            match = re.search(r'"currentVersion":\s*"([^"]+)"', content)
            current = match.group(1) if match else current
          elif "CURRENT_VERSION" in content:
            version_key = "CURRENT_VERSION"
            match = re.search(r'CURRENT_VERSION\s*=\s*["\']([^"\']+)["\']', content)
            current = match.group(1) if match else current
          elif "__version__" in content:
            version_key = "__version__"
            match = re.search(r'__version__\s*=\s*["\']([^"\']+)["\']', content)
            current = match.group(1) if match else current
          else:
            version_key = "unknown"

          tag_name = f"v{version}-{tool['build_name']}"

          print(f"‚úì Found tool: {tool['display_name']} (build_name: {tool['build_name']})")
          print(f"‚úì Config file: {config_path}")
          print(f"  Version key: {version_key}")
          print(f"  Current version: {current}")
          print(f"  Target version: {version}")
          print(f"  Tag: {tag_name}")

          if current == version:
            print(f"‚ö†Ô∏è  Warning: Version already set to {version}")

          with open(os.environ["GITHUB_OUTPUT"], "a") as gh_out:
            gh_out.write(f"config_file={config_path}\n")
            gh_out.write(f"tag_name={tag_name}\n")
            gh_out.write(f"display_name={tool['display_name']}\n")
            gh_out.write(f"current_version={current}\n")
            gh_out.write(f"version_key={version_key}\n")
            gh_out.write(f"tool_dir={tool['tool_dir']}\n")
            gh_out.write(f"build_name={tool['build_name']}\n")

          print("=== Validation complete ===")
          PYTHON_SCRIPT
        env:
          INPUT_TOOL: ${{ github.event.inputs.tool }}
          INPUT_VERSION: ${{ github.event.inputs.version }}
        shell: bash

      - name: Check tag availability
        run: |
          TAG="${{ steps.config.outputs.tag_name }}"
          
          git fetch --tags --quiet
          
          if git rev-parse "refs/tags/$TAG" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Warning: Tag $TAG already exists and will be overwritten"
          else
            echo "‚úì Tag $TAG is available"
          fi
        shell: bash

  bump-version:
    name: Bump Version
    needs: validate
    if: github.event.inputs.skip_version_bump != 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.name "GitHub Action"
          git config --global user.email "action@github.com"

      - name: Update version in config
        run: |
          VERSION="${{ github.event.inputs.version }}"
          CONFIG_FILE="${{ needs.validate.outputs.config_file }}"
          VERSION_KEY="${{ needs.validate.outputs.version_key }}"
          
          echo "Updating $CONFIG_FILE to version $VERSION"
          python3 << 'PYTHON_SCRIPT'
          import os
          import re
          import sys
          from pathlib import Path

          config_path = Path(os.environ["CONFIG_FILE"])
          version = os.environ["VERSION"]
          version_key = os.environ["VERSION_KEY"]
          text = config_path.read_text()
          new_text = text

          if version_key == "currentVersion":
            new_text = re.sub(r'"currentVersion":\s*"[^"]*"', f'"currentVersion": "{version}"', text)
          elif version_key == "CURRENT_VERSION":
            new_text = re.sub(r'CURRENT_VERSION\s*=\s*["\'][^"\']*["\']', f'CURRENT_VERSION = "{version}"', text)
          elif version_key == "__version__":
            new_text = re.sub(r'__version__\s*=\s*["\'][^"\']*["\']', f'__version__ = "{version}"', text)
          else:
            print(f"‚ùå Unsupported version key: {version_key}")
            sys.exit(1)

          if new_text == text:
            print("‚ùå Version value not replaced; check the pattern.")
            sys.exit(1)

          config_path.write_text(new_text)
          print("Updated config:")
          for line in new_text.splitlines():
            if "currentVersion" in line or "CURRENT_VERSION" in line or "__version__" in line:
              print(line)
          PYTHON_SCRIPT
        shell: bash
        env:
          CONFIG_FILE: ${{ needs.validate.outputs.config_file }}
          VERSION: ${{ github.event.inputs.version }}
          VERSION_KEY: ${{ needs.validate.outputs.version_key }}

      - name: Commit version bump
        run: |
          TOOL="${{ needs.validate.outputs.build_name }}"
          VERSION="${{ github.event.inputs.version }}"
          CONFIG_FILE="${{ needs.validate.outputs.config_file }}"
          
          git add "$CONFIG_FILE"
          git commit -m "chore($TOOL): bump version to $VERSION"
          git push origin master
        shell: bash

  create-release:
    name: Create Pre-Release
    needs: [validate, bump-version]
    if: always() && needs.validate.result == 'success' && (needs.bump-version.result == 'success' || needs.bump-version.result == 'skipped')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: master
          fetch-depth: 0

      - name: Create tag
        run: |
          TAG="${{ needs.validate.outputs.tag_name }}"
          
          # Pull latest changes (in case version was bumped)
          git pull origin master
          
          # Create/update tag
          git tag -f "$TAG"
          git push origin "refs/tags/$TAG" --force
          
          echo "‚úì Tag $TAG created"
        shell: bash

      - name: Prepare release notes
        id: notes
        run: |
          VERSION="${{ github.event.inputs.version }}"
          DISPLAY_NAME="${{ needs.validate.outputs.display_name }}"
          USER_NOTES="${{ github.event.inputs.release_notes }}"
          
          if [ -n "$USER_NOTES" ]; then
            NOTES="$USER_NOTES"
          else
            NOTES="## $DISPLAY_NAME v$VERSION

### Changes

- See commit history for details

### Installation

Download the appropriate archive for your platform:
- **Windows x64**: \`${DISPLAY_NAME}_Windows_x64.zip\`
- **Windows x86**: \`${DISPLAY_NAME}_Windows_x86.zip\`
- **Linux x64**: \`${DISPLAY_NAME}_Linux_x64.zip\`
- **macOS x64**: \`${DISPLAY_NAME}_Mac_x64.zip\`"
          fi
          
          # Save to file to preserve newlines
          echo "$NOTES" > release_notes.md
        shell: bash

      - name: Create pre-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ needs.validate.outputs.tag_name }}"
          DISPLAY_NAME="${{ needs.validate.outputs.display_name }}"
          VERSION="${{ github.event.inputs.version }}"
          
          gh release create "$TAG" \
            --prerelease \
            --title "$DISPLAY_NAME v$VERSION" \
            --notes-file release_notes.md
          
          echo "‚úì Pre-release created: $TAG"
          echo ""
          echo "üöÄ The release workflow will now run automatically!"
          echo "   Monitor progress in the Actions tab."
        shell: bash

  summary:
    name: Summary
    needs: [validate, bump-version, create-release]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Generate summary
        run: |
          echo "# üöÄ Release Creation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Tool:** ${{ needs.validate.outputs.display_name }} (build: ${{ needs.validate.outputs.build_name }})" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ github.event.inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Tag:** ${{ needs.validate.outputs.tag_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "## Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.validate.result }}" = "success" ]; then
            echo "- ‚úÖ Validation passed" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ùå Validation failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ github.event.inputs.skip_version_bump }}" = "true" ]; then
            echo "- ‚è≠Ô∏è Version bump skipped (already updated)" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.bump-version.result }}" = "success" ]; then
            echo "- ‚úÖ Version bumped to ${{ github.event.inputs.version }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ùå Version bump failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ needs.create-release.result }}" = "success" ]; then
            echo "- ‚úÖ Pre-release created" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ùå Pre-release creation failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.create-release.result }}" = "success" ]; then
            echo "## Next Steps" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The release workflow has been triggered automatically!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "1. üîç [Monitor the release workflow](../actions)" >> $GITHUB_STEP_SUMMARY
            echo "2. ‚è≥ Wait for builds to complete (~15-20 minutes)" >> $GITHUB_STEP_SUMMARY
            echo "3. üéâ Release will be finalized automatically" >> $GITHUB_STEP_SUMMARY
          else
            echo "## Troubleshooting" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Check the failed job logs above for details." >> $GITHUB_STEP_SUMMARY
          fi
        shell: bash

