<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Panda3D: HTTPChannel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Panda3D
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepanda3d.html">panda3d</a></li><li class="navelem"><a class="el" href="namespacepanda3d_1_1core.html">core</a></li><li class="navelem"><a class="el" href="classpanda3d_1_1core_1_1HTTPChannel.html">HTTPChannel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classpanda3d_1_1core_1_1HTTPChannel-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">HTTPChannel Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A single channel of communication from an <a class="el" href="classpanda3d_1_1core_1_1HTTPClient.html" title="Handles contacting an HTTP server and retrieving a document.">HTTPClient</a>.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;pandadoc.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for HTTPChannel:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpanda3d_1_1core_1_1HTTPChannel.png" usemap="#HTTPChannel_map" alt=""/>
  <map id="HTTPChannel_map" name="HTTPChannel_map">
<area href="classpanda3d_1_1core_1_1TypedReferenceCount.html" title="A base class for things which need to inherit from both TypedObject and from ReferenceCount." alt="TypedReferenceCount" shape="rect" coords="74,112,213,136"/>
<area href="classpanda3d_1_1core_1_1TypedObject.html" title="This is an abstract class that all classes which use TypeHandle, and also provide virtual functions t..." alt="TypedObject" shape="rect" coords="0,56,139,80"/>
<area href="classpanda3d_1_1core_1_1ReferenceCount.html" title="A base class for all things that want to be reference-counted." alt="ReferenceCount" shape="rect" coords="149,56,288,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae98a46f4ea1a43ca48acaf15d2eb7113" id="r_ae98a46f4ea1a43ca48acaf15d2eb7113"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113">StatusCode</a> { <br />
&#160;&#160;<a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113ab6199f85d54c8d0b26e07dbd928cbd34">SC_incomplete</a> = 0
, <a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113ab523f677e7fd8cff192876182c6894bf">SC_internal_error</a> = 1
, <a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113ad2af2837621278bca55512447cad85a1">SC_no_connection</a> = 2
, <a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113a958d63ae52623c2eb8a6c32ba08d5e95">SC_timeout</a> = 3
, <br />
&#160;&#160;<a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113a6aceee3ad9c49e5f9ea67721afc8f191">SC_lost_connection</a> = 4
, <a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113a1b0b94ee206270e80c5be752a0fd7c5e">SC_non_http_response</a> = 5
, <a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113ac5b296164b82ff5332337570fccde466">SC_invalid_http</a> = 6
, <a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113aa8b6454880e0abc5aa1694b6ce2695d7">SC_socks_invalid_version</a> = 7
, <br />
&#160;&#160;<a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113a1e1e4dd0f5ba15095cc9df3e55ff49fa">SC_socks_no_acceptable_login_method</a> = 8
, <a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113ab01dd6595b408e3efe8382ccb7da33a1">SC_socks_refused</a> = 9
, <a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113ac928b46da2455e3126f06e6d66958feb">SC_socks_no_connection</a> = 10
, <a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113a52f7e6e185ae0618bde0564546907f66">SC_ssl_internal_failure</a> = 11
, <br />
&#160;&#160;<a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113a8db172b55bd79efe9ff89b134a419070">SC_ssl_no_handshake</a> = 12
, <a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113aa6c9041771b15e224e88c1c5f5151e65">SC_http_error_watermark</a> = 13
, <a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113a984b9757941eafb88f257a00c3e28353">SC_ssl_invalid_server_certificate</a> = 14
, <a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113acb64a6045d6e401d8b1d93d8eb6ff20f">SC_ssl_self_signed_server_certificate</a> = 15
, <br />
&#160;&#160;<a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113afe02f7b9ccfdf9550211b599784e4389">SC_ssl_unexpected_server</a> = 16
, <a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113a025f16bf0178b2c21b2d8ee2553641c7">SC_download_open_error</a> = 17
, <a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113a8c43a2b2e86d9c55ad30c8e54cc2bee7">SC_download_write_error</a> = 18
, <a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113a7f28c465126b4084b360e2b8aee4e316">SC_download_invalid_range</a> = 19
<br />
 }</td></tr>
<tr class="separator:ae98a46f4ea1a43ca48acaf15d2eb7113"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac9b8f0cacbce0fcebb71797390c6132b" id="r_ac9b8f0cacbce0fcebb71797390c6132b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9b8f0cacbce0fcebb71797390c6132b">__init__</a> (const <a class="el" href="classpanda3d_1_1core_1_1HTTPChannel.html">HTTPChannel</a>)</td></tr>
<tr class="separator:ac9b8f0cacbce0fcebb71797390c6132b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3e5ac7e5658df540f619452d82a403" id="r_aac3e5ac7e5658df540f619452d82a403"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac3e5ac7e5658df540f619452d82a403">beginConnectTo</a> (const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a> url)</td></tr>
<tr class="memdesc:aac3e5ac7e5658df540f619452d82a403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a non-blocking request to establish a direct connection to the server and port indicated by the URL.  <br /></td></tr>
<tr class="separator:aac3e5ac7e5658df540f619452d82a403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e528d05784a9a63bcc91496e1d66784" id="r_a9e528d05784a9a63bcc91496e1d66784"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e528d05784a9a63bcc91496e1d66784">beginGetDocument</a> (const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a> url)</td></tr>
<tr class="memdesc:a9e528d05784a9a63bcc91496e1d66784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a non-blocking request to retrieve a given document.  <br /></td></tr>
<tr class="separator:a9e528d05784a9a63bcc91496e1d66784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7677d757ac25d89fa5ab5972306ab5b5" id="r_a7677d757ac25d89fa5ab5972306ab5b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7677d757ac25d89fa5ab5972306ab5b5">beginGetHeader</a> (const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a> url)</td></tr>
<tr class="memdesc:a7677d757ac25d89fa5ab5972306ab5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a non-blocking request to retrieve a given header.  <br /></td></tr>
<tr class="separator:a7677d757ac25d89fa5ab5972306ab5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7680669b3c64515454d28151c82177" id="r_aac7680669b3c64515454d28151c82177"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac7680669b3c64515454d28151c82177">beginGetSubdocument</a> (const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a> url, int first_byte, int last_byte)</td></tr>
<tr class="memdesc:aac7680669b3c64515454d28151c82177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins a non-blocking request to retrieve only the specified byte range of the indicated document.  <br /></td></tr>
<tr class="separator:aac7680669b3c64515454d28151c82177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42e4c6ba72f46d4c050e1739890f474" id="r_aa42e4c6ba72f46d4c050e1739890f474"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa42e4c6ba72f46d4c050e1739890f474">beginPostForm</a> (const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a> url, str body)</td></tr>
<tr class="memdesc:aa42e4c6ba72f46d4c050e1739890f474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts form data to a particular URL and retrieves the response, all using non-blocking I/O.  <br /></td></tr>
<tr class="separator:aa42e4c6ba72f46d4c050e1739890f474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8cb8cab06d2e0cfe049d801bea640a" id="r_aed8cb8cab06d2e0cfe049d801bea640a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed8cb8cab06d2e0cfe049d801bea640a">clearExtraHeaders</a> ()</td></tr>
<tr class="memdesc:aed8cb8cab06d2e0cfe049d801bea640a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the extra headers that were previously added via calls to send_extra_header().  <br /></td></tr>
<tr class="separator:aed8cb8cab06d2e0cfe049d801bea640a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f66f14b00534e51c55887fbedc40fb" id="r_af1f66f14b00534e51c55887fbedc40fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1f66f14b00534e51c55887fbedc40fb">closeReadBody</a> (<a class="el" href="classpanda3d_1_1core_1_1Istream.html">Istream</a> stream)</td></tr>
<tr class="memdesc:af1f66f14b00534e51c55887fbedc40fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a file opened by a previous call to open_read_body().  <br /></td></tr>
<tr class="separator:af1f66f14b00534e51c55887fbedc40fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca6b206155cddaf3655622c6fd048a6" id="r_a8ca6b206155cddaf3655622c6fd048a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ca6b206155cddaf3655622c6fd048a6">connectTo</a> (const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a> url)</td></tr>
<tr class="memdesc:a8ca6b206155cddaf3655622c6fd048a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a direct connection to the server and port indicated by the URL, but do not issue any HTTP requests.  <br /></td></tr>
<tr class="separator:a8ca6b206155cddaf3655622c6fd048a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa49da0e2300a67310986c2ee849576" id="r_a9fa49da0e2300a67310986c2ee849576"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fa49da0e2300a67310986c2ee849576">deleteDocument</a> (const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a> url)</td></tr>
<tr class="memdesc:a9fa49da0e2300a67310986c2ee849576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests the server to remove the indicated URL.  <br /></td></tr>
<tr class="separator:a9fa49da0e2300a67310986c2ee849576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f0f7dc80424eb3d3302d9a78dfdddd" id="r_a52f0f7dc80424eb3d3302d9a78dfdddd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52f0f7dc80424eb3d3302d9a78dfdddd">downloadToFile</a> (const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a> filename, bool subdocument_resumes)</td></tr>
<tr class="memdesc:a52f0f7dc80424eb3d3302d9a78dfdddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the name of a file to download the resulting document to.  <br /></td></tr>
<tr class="separator:a52f0f7dc80424eb3d3302d9a78dfdddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f25f1525d04bd5cebf77442548760f" id="r_a79f25f1525d04bd5cebf77442548760f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79f25f1525d04bd5cebf77442548760f">downloadToRam</a> (<a class="el" href="classpanda3d_1_1core_1_1Ramfile.html">Ramfile</a> ramfile, bool subdocument_resumes)</td></tr>
<tr class="memdesc:a79f25f1525d04bd5cebf77442548760f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a <a class="el" href="classpanda3d_1_1core_1_1Ramfile.html" title="An in-memory buffer specifically designed for downloading files to memory.">Ramfile</a> object to download the resulting document to.  <br /></td></tr>
<tr class="separator:a79f25f1525d04bd5cebf77442548760f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083637ffe516232465c6fe3efc299417" id="r_a083637ffe516232465c6fe3efc299417"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a083637ffe516232465c6fe3efc299417">downloadToStream</a> (<a class="el" href="classpanda3d_1_1core_1_1Ostream.html">Ostream</a> strm, bool subdocument_resumes)</td></tr>
<tr class="memdesc:a083637ffe516232465c6fe3efc299417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the name of an ostream to download the resulting document to.  <br /></td></tr>
<tr class="separator:a083637ffe516232465c6fe3efc299417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e27a1fd3f1944699a1f5939d4d80e43" id="r_a8e27a1fd3f1944699a1f5939d4d80e43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e27a1fd3f1944699a1f5939d4d80e43">getAllowProxy</a> ()</td></tr>
<tr class="memdesc:a8e27a1fd3f1944699a1f5939d4d80e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this is true (the normal case), the <a class="el" href="classpanda3d_1_1core_1_1HTTPClient.html" title="Handles contacting an HTTP server and retrieving a document.">HTTPClient</a> will be consulted for information about the proxy to be used for each connection via this <a class="el" href="classpanda3d_1_1core_1_1HTTPChannel.html" title="A single channel of communication from an HTTPClient.">HTTPChannel</a>.  <br /></td></tr>
<tr class="separator:a8e27a1fd3f1944699a1f5939d4d80e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d90f3382d6b8afd16a5fcbd953680e" id="r_a34d90f3382d6b8afd16a5fcbd953680e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34d90f3382d6b8afd16a5fcbd953680e">getBlockingConnect</a> ()</td></tr>
<tr class="memdesc:a34d90f3382d6b8afd16a5fcbd953680e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this flag is true, a socket connect will block even for nonblocking I/O calls like begin_get_document(), begin_connect_to(), etc.  <br /></td></tr>
<tr class="separator:a34d90f3382d6b8afd16a5fcbd953680e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2743a7c6237af60561d6a5680c792e2e" id="r_a2743a7c6237af60561d6a5680c792e2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2743a7c6237af60561d6a5680c792e2e">getBytesDownloaded</a> ()</td></tr>
<tr class="memdesc:a2743a7c6237af60561d6a5680c792e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes downloaded during the last (or current) download_to_file() or download_to_ram operation().  <br /></td></tr>
<tr class="separator:a2743a7c6237af60561d6a5680c792e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27005d4997e152957c7d688a1d110e5" id="r_ae27005d4997e152957c7d688a1d110e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae27005d4997e152957c7d688a1d110e5">getBytesRequested</a> ()</td></tr>
<tr class="memdesc:ae27005d4997e152957c7d688a1d110e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">When download throttling is in effect (set_download_throttle() has been set to true) and non-blocking I/O methods (like begin_get_document()) are used, this returns the number of bytes "requested" from the server so far: that is, the theoretical maximum value for get_bytes_downloaded(), if the server has been keeping up with our demand.  <br /></td></tr>
<tr class="separator:ae27005d4997e152957c7d688a1d110e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1814c41daa359139ce416e11b648fdb6" id="r_a1814c41daa359139ce416e11b648fdb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpanda3d_1_1core_1_1HTTPClient.html">HTTPClient</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1814c41daa359139ce416e11b648fdb6">getClient</a> ()</td></tr>
<tr class="memdesc:a1814c41daa359139ce416e11b648fdb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classpanda3d_1_1core_1_1HTTPClient.html" title="Handles contacting an HTTP server and retrieving a document.">HTTPClient</a> object that owns this channel.  <br /></td></tr>
<tr class="separator:a1814c41daa359139ce416e11b648fdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c50ab742c0dae90289475d234d93b01" id="r_a5c50ab742c0dae90289475d234d93b01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpanda3d_1_1core_1_1SocketStream.html">SocketStream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c50ab742c0dae90289475d234d93b01">getConnection</a> ()</td></tr>
<tr class="memdesc:a5c50ab742c0dae90289475d234d93b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the connection that was established via a previous call to connect_to() or begin_connect_to(), or NULL if the connection attempt failed or if those methods have not recently been called.  <br /></td></tr>
<tr class="separator:a5c50ab742c0dae90289475d234d93b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24cf7db191a7c96c208d25af76a7a2f7" id="r_a24cf7db191a7c96c208d25af76a7a2f7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24cf7db191a7c96c208d25af76a7a2f7">getConnectTimeout</a> ()</td></tr>
<tr class="memdesc:a24cf7db191a7c96c208d25af76a7a2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of time, in seconds, to wait for a new nonblocking socket to connect.  <br /></td></tr>
<tr class="separator:a24cf7db191a7c96c208d25af76a7a2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa055f565e51ae55f654beec638b544" id="r_a9fa055f565e51ae55f654beec638b544"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fa055f565e51ae55f654beec638b544">getContentType</a> ()</td></tr>
<tr class="memdesc:a9fa055f565e51ae55f654beec638b544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the Content-Type header.  <br /></td></tr>
<tr class="separator:a9fa055f565e51ae55f654beec638b544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f4f65e5b313777916347b6e0855615" id="r_ad3f4f65e5b313777916347b6e0855615"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3f4f65e5b313777916347b6e0855615">getDocument</a> (const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a> url)</td></tr>
<tr class="memdesc:ad3f4f65e5b313777916347b6e0855615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the named document for reading, if available.  <br /></td></tr>
<tr class="separator:ad3f4f65e5b313777916347b6e0855615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee356412ab38659490fbfaedf153a26" id="r_a9ee356412ab38659490fbfaedf153a26"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ee356412ab38659490fbfaedf153a26">getDocumentSpec</a> ()</td></tr>
<tr class="memdesc:a9ee356412ab38659490fbfaedf153a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html" title="A descriptor that refers to a particular version of a document.">DocumentSpec</a> associated with the most recent document.  <br /></td></tr>
<tr class="separator:a9ee356412ab38659490fbfaedf153a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55465a200cc0b6ad65124d80fbd4cd62" id="r_a55465a200cc0b6ad65124d80fbd4cd62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55465a200cc0b6ad65124d80fbd4cd62">getDownloadThrottle</a> ()</td></tr>
<tr class="memdesc:a55465a200cc0b6ad65124d80fbd4cd62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the nonblocking downloads will be bandwidth-limited.  <br /></td></tr>
<tr class="separator:a55465a200cc0b6ad65124d80fbd4cd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c163af5216d2dbf340689aa40b9dcf" id="r_a86c163af5216d2dbf340689aa40b9dcf"><td class="memItemLeft" align="right" valign="top">Streamsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86c163af5216d2dbf340689aa40b9dcf">getFileSize</a> ()</td></tr>
<tr class="memdesc:a86c163af5216d2dbf340689aa40b9dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the file, if it is known.  <br /></td></tr>
<tr class="separator:a86c163af5216d2dbf340689aa40b9dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7acf4faafdfef0d97de3df498ea963" id="r_afc7acf4faafdfef0d97de3df498ea963"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc7acf4faafdfef0d97de3df498ea963">getFirstByteDelivered</a> ()</td></tr>
<tr class="memdesc:afc7acf4faafdfef0d97de3df498ea963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first byte of the file (that will be) delivered by the server in response to the current request.  <br /></td></tr>
<tr class="separator:afc7acf4faafdfef0d97de3df498ea963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe9f83aaa816dd67173ee267ff36ac6" id="r_aafe9f83aaa816dd67173ee267ff36ac6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafe9f83aaa816dd67173ee267ff36ac6">getFirstByteRequested</a> ()</td></tr>
<tr class="memdesc:aafe9f83aaa816dd67173ee267ff36ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first byte of the file requested by the request.  <br /></td></tr>
<tr class="separator:aafe9f83aaa816dd67173ee267ff36ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac157ba4dedb265f111630b2576e6a6cd" id="r_ac157ba4dedb265f111630b2576e6a6cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac157ba4dedb265f111630b2576e6a6cd">getHeader</a> (const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a> url)</td></tr>
<tr class="memdesc:ac157ba4dedb265f111630b2576e6a6cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like get_document(), except only the header associated with the document is retrieved.  <br /></td></tr>
<tr class="separator:ac157ba4dedb265f111630b2576e6a6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa3dee8ab5f1c1d4b2e9c0e5a558a18" id="r_abfa3dee8ab5f1c1d4b2e9c0e5a558a18"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfa3dee8ab5f1c1d4b2e9c0e5a558a18">getHeaderValue</a> (str key)</td></tr>
<tr class="memdesc:abfa3dee8ab5f1c1d4b2e9c0e5a558a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the HTML header value associated with the indicated key, or empty string if the key was not defined in the message returned by the server.  <br /></td></tr>
<tr class="separator:abfa3dee8ab5f1c1d4b2e9c0e5a558a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ac7b91b85bece2d51ae6bcc525fa1d" id="r_a10ac7b91b85bece2d51ae6bcc525fa1d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10ac7b91b85bece2d51ae6bcc525fa1d">getHttpTimeout</a> ()</td></tr>
<tr class="memdesc:a10ac7b91b85bece2d51ae6bcc525fa1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of time, in seconds, to wait for the HTTP server to respond to our request.  <br /></td></tr>
<tr class="separator:a10ac7b91b85bece2d51ae6bcc525fa1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea6c8f763b89c04ad030eb53b94e422" id="r_aaea6c8f763b89c04ad030eb53b94e422"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpanda3d_1_1core_1_1HTTPEnum.html#abe818f5ff14e9c60c052a3e96877cec6">HTTPEnum::HTTPVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaea6c8f763b89c04ad030eb53b94e422">getHttpVersion</a> ()</td></tr>
<tr class="memdesc:aaea6c8f763b89c04ad030eb53b94e422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the HTTP version number returned by the server, as one of the <a class="el" href="classpanda3d_1_1core_1_1HTTPClient.html" title="Handles contacting an HTTP server and retrieving a document.">HTTPClient</a> enumerated types, e.g.  <br /></td></tr>
<tr class="separator:aaea6c8f763b89c04ad030eb53b94e422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3a10a5fe1fc3d36b3c723629510981" id="r_a6e3a10a5fe1fc3d36b3c723629510981"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e3a10a5fe1fc3d36b3c723629510981">getHttpVersionString</a> ()</td></tr>
<tr class="memdesc:a6e3a10a5fe1fc3d36b3c723629510981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the HTTP version number returned by the server, formatted as a string, e.g.  <br /></td></tr>
<tr class="separator:a6e3a10a5fe1fc3d36b3c723629510981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1851c6ae5648db0ba73d7b3b000f5e5" id="r_af1851c6ae5648db0ba73d7b3b000f5e5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1851c6ae5648db0ba73d7b3b000f5e5">getIdleTimeout</a> ()</td></tr>
<tr class="memdesc:af1851c6ae5648db0ba73d7b3b000f5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of time, in seconds, in which an previously-established connection is allowed to remain open and unused.  <br /></td></tr>
<tr class="separator:af1851c6ae5648db0ba73d7b3b000f5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556644d6e27eb09ae78c460ede06aa35" id="r_a556644d6e27eb09ae78c460ede06aa35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a556644d6e27eb09ae78c460ede06aa35">getLastByteDelivered</a> ()</td></tr>
<tr class="memdesc:a556644d6e27eb09ae78c460ede06aa35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last byte of the file (that will be) delivered by the server in response to the current request.  <br /></td></tr>
<tr class="separator:a556644d6e27eb09ae78c460ede06aa35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01ccc12644499a46da32911e38af4a8" id="r_ad01ccc12644499a46da32911e38af4a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad01ccc12644499a46da32911e38af4a8">getLastByteRequested</a> ()</td></tr>
<tr class="memdesc:ad01ccc12644499a46da32911e38af4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last byte of the file requested by the request.  <br /></td></tr>
<tr class="separator:ad01ccc12644499a46da32911e38af4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7df96a2b0b9b61d3012557ba9e803be" id="r_aa7df96a2b0b9b61d3012557ba9e803be"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7df96a2b0b9b61d3012557ba9e803be">getMaxBytesPerSecond</a> ()</td></tr>
<tr class="memdesc:aa7df96a2b0b9b61d3012557ba9e803be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of bytes per second that may be consumed by this channel when get_download_throttle() is true.  <br /></td></tr>
<tr class="separator:aa7df96a2b0b9b61d3012557ba9e803be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0437efb3dd7b49bffc503747bb9cd69" id="r_aa0437efb3dd7b49bffc503747bb9cd69"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0437efb3dd7b49bffc503747bb9cd69">getMaxUpdatesPerSecond</a> ()</td></tr>
<tr class="memdesc:aa0437efb3dd7b49bffc503747bb9cd69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of times per second that <a class="el" href="#a149ad6701e3e2414cb566bb414029841" title="This must be called from time to time when non-blocking I/O is in use.">run()</a> will do anything at all, when get_download_throttle() is true.  <br /></td></tr>
<tr class="separator:aa0437efb3dd7b49bffc503747bb9cd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917e3d5361a473e626c901b22bcf2dc0" id="r_a917e3d5361a473e626c901b22bcf2dc0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a917e3d5361a473e626c901b22bcf2dc0">getNumRedirectSteps</a> ()</td></tr>
<tr class="memdesc:a917e3d5361a473e626c901b22bcf2dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the document automatically followed one or more redirects, this will return the number of redirects that were automatically followed.  <br /></td></tr>
<tr class="separator:a917e3d5361a473e626c901b22bcf2dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf22f98730e58cdae4030a01d363527a" id="r_adf22f98730e58cdae4030a01d363527a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf22f98730e58cdae4030a01d363527a">getOptions</a> (const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a> url)</td></tr>
<tr class="memdesc:adf22f98730e58cdae4030a01d363527a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an OPTIONS message to the server, which should query the available options, possibly in relation to a specified URL.  <br /></td></tr>
<tr class="separator:adf22f98730e58cdae4030a01d363527a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44632a2434ddce5cabbd908e41ea93ed" id="r_a44632a2434ddce5cabbd908e41ea93ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44632a2434ddce5cabbd908e41ea93ed">getPersistentConnection</a> ()</td></tr>
<tr class="memdesc:a44632a2434ddce5cabbd908e41ea93ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the <a class="el" href="classpanda3d_1_1core_1_1HTTPChannel.html" title="A single channel of communication from an HTTPClient.">HTTPChannel</a> should try to keep the connection to the server open and reuse that connection for multiple documents, or whether it should close the connection and open a new one for each request.  <br /></td></tr>
<tr class="separator:a44632a2434ddce5cabbd908e41ea93ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2863611391e1a4c28422881d64a1ce6" id="r_ab2863611391e1a4c28422881d64a1ce6"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2863611391e1a4c28422881d64a1ce6">getProxyRealm</a> ()</td></tr>
<tr class="memdesc:ab2863611391e1a4c28422881d64a1ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the document failed to connect because of a 407 (Proxy authorization required), this method will return the "realm" returned by the proxy.  <br /></td></tr>
<tr class="separator:ab2863611391e1a4c28422881d64a1ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e861abd3c8d9118669724a6b54ff062" id="r_a0e861abd3c8d9118669724a6b54ff062"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e861abd3c8d9118669724a6b54ff062">getProxyTunnel</a> ()</td></tr>
<tr class="memdesc:a0e861abd3c8d9118669724a6b54ff062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if connections always tunnel through a proxy, or false (the normal case) if we allow the proxy to serve up documents.  <br /></td></tr>
<tr class="separator:a0e861abd3c8d9118669724a6b54ff062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e695514506a5bce4c8fc5ded777dab" id="r_ac5e695514506a5bce4c8fc5ded777dab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpanda3d_1_1core_1_1URLSpec.html">URLSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5e695514506a5bce4c8fc5ded777dab">getRedirect</a> ()</td></tr>
<tr class="memdesc:ac5e695514506a5bce4c8fc5ded777dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the document failed with a redirect code (300 series), this will generally contain the new URL the server wants us to try.  <br /></td></tr>
<tr class="separator:ac5e695514506a5bce4c8fc5ded777dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92cff8ae39be87fea641b79bf310a8e" id="r_ad92cff8ae39be87fea641b79bf310a8e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpanda3d_1_1core_1_1URLSpec.html">URLSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad92cff8ae39be87fea641b79bf310a8e">getRedirectStep</a> (int n)</td></tr>
<tr class="memdesc:ad92cff8ae39be87fea641b79bf310a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use in conjunction with get_num_redirect_steps() to extract the chain of URL's that the channel was automatically redirected through to arrive at the final document.  <br /></td></tr>
<tr class="separator:ad92cff8ae39be87fea641b79bf310a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3366d1fd890cfc9c922ff43c67c49537" id="r_a3366d1fd890cfc9c922ff43c67c49537"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3366d1fd890cfc9c922ff43c67c49537">getRedirectSteps</a> ()</td></tr>
<tr class="separator:a3366d1fd890cfc9c922ff43c67c49537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7de7300525ee8e94faaa3e1dc7fadd" id="r_adc7de7300525ee8e94faaa3e1dc7fadd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc7de7300525ee8e94faaa3e1dc7fadd">getSkipBodySize</a> ()</td></tr>
<tr class="memdesc:adc7de7300525ee8e94faaa3e1dc7fadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of bytes in a received (but unwanted) body that will be skipped past, in order to reset to a new request.  <br /></td></tr>
<tr class="separator:adc7de7300525ee8e94faaa3e1dc7fadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328ca7b0d5e311df982f9d48d9724bb1" id="r_a328ca7b0d5e311df982f9d48d9724bb1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a328ca7b0d5e311df982f9d48d9724bb1">getStatusCode</a> ()</td></tr>
<tr class="memdesc:a328ca7b0d5e311df982f9d48d9724bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the HTML return code from the document retrieval request.  <br /></td></tr>
<tr class="separator:a328ca7b0d5e311df982f9d48d9724bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c48f33ee430194f7d0e16d948a44cc" id="r_ae3c48f33ee430194f7d0e16d948a44cc"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3c48f33ee430194f7d0e16d948a44cc">getStatusString</a> ()</td></tr>
<tr class="memdesc:ae3c48f33ee430194f7d0e16d948a44cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the string as returned by the server describing the status code for humans.  <br /></td></tr>
<tr class="separator:ae3c48f33ee430194f7d0e16d948a44cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a199930b7b8584bf3d25c08c2834d3" id="r_a69a199930b7b8584bf3d25c08c2834d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69a199930b7b8584bf3d25c08c2834d3">getSubdocument</a> (const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a> url, int first_byte, int last_byte)</td></tr>
<tr class="memdesc:a69a199930b7b8584bf3d25c08c2834d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves only the specified byte range of the indicated document.  <br /></td></tr>
<tr class="separator:a69a199930b7b8584bf3d25c08c2834d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d9fa5a0bfe6e58c078ae842ef37452" id="r_ab6d9fa5a0bfe6e58c078ae842ef37452"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6d9fa5a0bfe6e58c078ae842ef37452">getTrace</a> (const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a> url)</td></tr>
<tr class="memdesc:ab6d9fa5a0bfe6e58c078ae842ef37452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a TRACE message to the server, which should return back the same message as the server received it, allowing inspection of proxy hops, etc.  <br /></td></tr>
<tr class="separator:ab6d9fa5a0bfe6e58c078ae842ef37452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c039bd775295afd5b799d24d6a33e9a" id="r_a6c039bd775295afd5b799d24d6a33e9a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpanda3d_1_1core_1_1URLSpec.html">URLSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c039bd775295afd5b799d24d6a33e9a">getUrl</a> ()</td></tr>
<tr class="memdesc:a6c039bd775295afd5b799d24d6a33e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the URL that was used to retrieve the most recent document: whatever URL was last passed to get_document() or get_header().  <br /></td></tr>
<tr class="separator:a6c039bd775295afd5b799d24d6a33e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d877fa4a4fd42fd3ace4def1a837cfa" id="r_a8d877fa4a4fd42fd3ace4def1a837cfa"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d877fa4a4fd42fd3ace4def1a837cfa">getWwwRealm</a> ()</td></tr>
<tr class="memdesc:a8d877fa4a4fd42fd3ace4def1a837cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the document failed to connect because of a 401 (Authorization required), this method will return the "realm" returned by the server in which the requested document must be authenticated.  <br /></td></tr>
<tr class="separator:a8d877fa4a4fd42fd3ace4def1a837cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246a4f78b2b15d0ee4da227c325cad94" id="r_a246a4f78b2b15d0ee4da227c325cad94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a246a4f78b2b15d0ee4da227c325cad94">isConnectionReady</a> ()</td></tr>
<tr class="memdesc:a246a4f78b2b15d0ee4da227c325cad94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a connection has been established to the named server in a previous call to connect_to() or begin_connect_to(), false otherwise.  <br /></td></tr>
<tr class="separator:a246a4f78b2b15d0ee4da227c325cad94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4a05dc0246ea225cc3dabf39385ba1" id="r_a1c4a05dc0246ea225cc3dabf39385ba1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c4a05dc0246ea225cc3dabf39385ba1">isDownloadComplete</a> ()</td></tr>
<tr class="memdesc:a1c4a05dc0246ea225cc3dabf39385ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true when a download_to() or download_to_ram() has executed and the file has been fully downloaded.  <br /></td></tr>
<tr class="separator:a1c4a05dc0246ea225cc3dabf39385ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5629e01ca1fed4bff5f2b69ccabae50d" id="r_a5629e01ca1fed4bff5f2b69ccabae50d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5629e01ca1fed4bff5f2b69ccabae50d">isFileSizeKnown</a> ()</td></tr>
<tr class="memdesc:a5629e01ca1fed4bff5f2b69ccabae50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the size of the file we are currently retrieving was told us by the server and thus is reliably known, or false if the size reported by get_file_size() represents an educated guess (possibly as set by set_expected_file_size(), or as inferred from a chunked transfer encoding in progress).  <br /></td></tr>
<tr class="separator:a5629e01ca1fed4bff5f2b69ccabae50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe93e17ac89cd97917811068ba2af214" id="r_afe93e17ac89cd97917811068ba2af214"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe93e17ac89cd97917811068ba2af214">isValid</a> ()</td></tr>
<tr class="memdesc:afe93e17ac89cd97917811068ba2af214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the last-requested document was successfully retrieved and is ready to be read, false otherwise.  <br /></td></tr>
<tr class="separator:afe93e17ac89cd97917811068ba2af214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc29122cde69faff4d9e6e20ec0df0a7" id="r_abc29122cde69faff4d9e6e20ec0df0a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpanda3d_1_1core_1_1ISocketStream.html">ISocketStream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc29122cde69faff4d9e6e20ec0df0a7">openReadBody</a> ()</td></tr>
<tr class="memdesc:abc29122cde69faff4d9e6e20ec0df0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a newly-allocated istream suitable for reading the body of the document.  <br /></td></tr>
<tr class="separator:abc29122cde69faff4d9e6e20ec0df0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596585d58d68672d6b6486ff3a6e9cba" id="r_a596585d58d68672d6b6486ff3a6e9cba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a596585d58d68672d6b6486ff3a6e9cba">postForm</a> (const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a> url, str body)</td></tr>
<tr class="memdesc:a596585d58d68672d6b6486ff3a6e9cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts form data to a particular URL and retrieves the response.  <br /></td></tr>
<tr class="separator:a596585d58d68672d6b6486ff3a6e9cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97d88594ea04119fd1141785a3d2792" id="r_af97d88594ea04119fd1141785a3d2792"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af97d88594ea04119fd1141785a3d2792">preserveStatus</a> ()</td></tr>
<tr class="memdesc:af97d88594ea04119fd1141785a3d2792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preserves the previous status code (presumably a failure) from the previous connection attempt.  <br /></td></tr>
<tr class="separator:af97d88594ea04119fd1141785a3d2792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da885d2caca28faa8d5ca6f9d532fdd" id="r_a4da885d2caca28faa8d5ca6f9d532fdd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4da885d2caca28faa8d5ca6f9d532fdd">putDocument</a> (const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a> url, str body)</td></tr>
<tr class="memdesc:a4da885d2caca28faa8d5ca6f9d532fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uploads the indicated body to the server to replace the indicated URL, if the server allows this.  <br /></td></tr>
<tr class="separator:a4da885d2caca28faa8d5ca6f9d532fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a20559544fdf4dcb457e258dc976cf8" id="r_a4a20559544fdf4dcb457e258dc976cf8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a20559544fdf4dcb457e258dc976cf8">reset</a> ()</td></tr>
<tr class="memdesc:a4a20559544fdf4dcb457e258dc976cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops whatever file transaction is currently in progress, closes the connection, and resets to begin anew.  <br /></td></tr>
<tr class="separator:a4a20559544fdf4dcb457e258dc976cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149ad6701e3e2414cb566bb414029841" id="r_a149ad6701e3e2414cb566bb414029841"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a149ad6701e3e2414cb566bb414029841">run</a> ()</td></tr>
<tr class="memdesc:a149ad6701e3e2414cb566bb414029841"><td class="mdescLeft">&#160;</td><td class="mdescRight">This must be called from time to time when non-blocking I/O is in use.  <br /></td></tr>
<tr class="separator:a149ad6701e3e2414cb566bb414029841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c35a92dfd817cf3ec2895fc203f2290" id="r_a6c35a92dfd817cf3ec2895fc203f2290"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c35a92dfd817cf3ec2895fc203f2290">sendExtraHeader</a> (str key, str value)</td></tr>
<tr class="memdesc:a6c35a92dfd817cf3ec2895fc203f2290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an additional key: value pair that is added into the header sent to the server with the next request.  <br /></td></tr>
<tr class="separator:a6c35a92dfd817cf3ec2895fc203f2290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c723f77dea3d31767468b46d90b1fe" id="r_a56c723f77dea3d31767468b46d90b1fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56c723f77dea3d31767468b46d90b1fe">setAllowProxy</a> (bool allow_proxy)</td></tr>
<tr class="memdesc:a56c723f77dea3d31767468b46d90b1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this is true (the normal case), the <a class="el" href="classpanda3d_1_1core_1_1HTTPClient.html" title="Handles contacting an HTTP server and retrieving a document.">HTTPClient</a> will be consulted for information about the proxy to be used for each connection via this <a class="el" href="classpanda3d_1_1core_1_1HTTPChannel.html" title="A single channel of communication from an HTTPClient.">HTTPChannel</a>.  <br /></td></tr>
<tr class="separator:a56c723f77dea3d31767468b46d90b1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac976b94be9c24bf79941b72bf095837a" id="r_ac976b94be9c24bf79941b72bf095837a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac976b94be9c24bf79941b72bf095837a">setBlockingConnect</a> (bool blocking_connect)</td></tr>
<tr class="memdesc:ac976b94be9c24bf79941b72bf095837a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this flag is true, a socket connect will block even for nonblocking I/O calls like begin_get_document(), begin_connect_to(), etc.  <br /></td></tr>
<tr class="separator:ac976b94be9c24bf79941b72bf095837a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a79dd23b482aa8b9174d147e745147b" id="r_a5a79dd23b482aa8b9174d147e745147b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a79dd23b482aa8b9174d147e745147b">setConnectTimeout</a> (double timeout_seconds)</td></tr>
<tr class="memdesc:a5a79dd23b482aa8b9174d147e745147b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum length of time, in seconds, that the channel will wait before giving up on establishing a TCP connection.  <br /></td></tr>
<tr class="separator:a5a79dd23b482aa8b9174d147e745147b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9596797ad071ff2ce5626aabb38ae95" id="r_af9596797ad071ff2ce5626aabb38ae95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9596797ad071ff2ce5626aabb38ae95">setContentType</a> (str content_type)</td></tr>
<tr class="memdesc:af9596797ad071ff2ce5626aabb38ae95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the Content-Type header, useful for applications that require different types of content, such as JSON.  <br /></td></tr>
<tr class="separator:af9596797ad071ff2ce5626aabb38ae95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c98002505f9d522e172ddfcaea7636" id="r_a77c98002505f9d522e172ddfcaea7636"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77c98002505f9d522e172ddfcaea7636">setDownloadThrottle</a> (bool download_throttle)</td></tr>
<tr class="memdesc:a77c98002505f9d522e172ddfcaea7636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether nonblocking downloads (via download_to_file() or download_to_ram()) will be limited so as not to use all available bandwidth.  <br /></td></tr>
<tr class="separator:a77c98002505f9d522e172ddfcaea7636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb26631dc347dfb022ebcf8a46466573" id="r_abb26631dc347dfb022ebcf8a46466573"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb26631dc347dfb022ebcf8a46466573">setExpectedFileSize</a> (int file_size)</td></tr>
<tr class="memdesc:abb26631dc347dfb022ebcf8a46466573"><td class="mdescLeft">&#160;</td><td class="mdescRight">This may be called immediately after a call to get_document() or some related function to specify the expected size of the document we are retrieving, if we happen to know.  <br /></td></tr>
<tr class="separator:abb26631dc347dfb022ebcf8a46466573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49156e3db9020679b447d883619f4163" id="r_a49156e3db9020679b447d883619f4163"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49156e3db9020679b447d883619f4163">setHttpTimeout</a> (double timeout_seconds)</td></tr>
<tr class="memdesc:a49156e3db9020679b447d883619f4163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum length of time, in seconds, that the channel will wait for the HTTP server to finish sending its response to our request.  <br /></td></tr>
<tr class="separator:a49156e3db9020679b447d883619f4163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfaafc3e7f11c17e12fd4665f07cf65b" id="r_adfaafc3e7f11c17e12fd4665f07cf65b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfaafc3e7f11c17e12fd4665f07cf65b">setIdleTimeout</a> (double idle_timeout)</td></tr>
<tr class="memdesc:adfaafc3e7f11c17e12fd4665f07cf65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the amount of time, in seconds, in which a previously-established connection is allowed to remain open and unused.  <br /></td></tr>
<tr class="separator:adfaafc3e7f11c17e12fd4665f07cf65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83899b253c4fc07a7ade67669516ed04" id="r_a83899b253c4fc07a7ade67669516ed04"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83899b253c4fc07a7ade67669516ed04">setMaxBytesPerSecond</a> (double max_bytes_per_second)</td></tr>
<tr class="memdesc:a83899b253c4fc07a7ade67669516ed04"><td class="mdescLeft">&#160;</td><td class="mdescRight">When bandwidth throttling is in effect (see set_download_throttle()), this specifies the maximum number of bytes per second that may be consumed by this channel.  <br /></td></tr>
<tr class="separator:a83899b253c4fc07a7ade67669516ed04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59085a5146fce383424a490bd71b13a" id="r_ad59085a5146fce383424a490bd71b13a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad59085a5146fce383424a490bd71b13a">setMaxUpdatesPerSecond</a> (double max_updates_per_second)</td></tr>
<tr class="memdesc:ad59085a5146fce383424a490bd71b13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">When bandwidth throttling is in effect (see set_download_throttle()), this specifies the maximum number of times per second that <a class="el" href="#a149ad6701e3e2414cb566bb414029841" title="This must be called from time to time when non-blocking I/O is in use.">run()</a> will attempt to do any downloading at all.  <br /></td></tr>
<tr class="separator:ad59085a5146fce383424a490bd71b13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00c438551731118217094f5e38b4383" id="r_ab00c438551731118217094f5e38b4383"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab00c438551731118217094f5e38b4383">setPersistentConnection</a> (bool persistent_connection)</td></tr>
<tr class="memdesc:ab00c438551731118217094f5e38b4383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the <a class="el" href="classpanda3d_1_1core_1_1HTTPChannel.html" title="A single channel of communication from an HTTPClient.">HTTPChannel</a> should try to keep the connection to the server open and reuse that connection for multiple documents, or whether it should close the connection and open a new one for each request.  <br /></td></tr>
<tr class="separator:ab00c438551731118217094f5e38b4383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc159cc3f041ec442e1dc84d20bf926" id="r_a6fc159cc3f041ec442e1dc84d20bf926"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fc159cc3f041ec442e1dc84d20bf926">setProxyTunnel</a> (bool proxy_tunnel)</td></tr>
<tr class="memdesc:a6fc159cc3f041ec442e1dc84d20bf926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normally, a proxy is itself asked for ordinary URL's, and the proxy decides whether to hand the client a cached version of the document or to contact the server for a fresh version.  <br /></td></tr>
<tr class="separator:a6fc159cc3f041ec442e1dc84d20bf926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dfb6dea4a2bc13ede4e5b3dd87ada9c" id="r_a3dfb6dea4a2bc13ede4e5b3dd87ada9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dfb6dea4a2bc13ede4e5b3dd87ada9c">setSkipBodySize</a> (int skip_body_size)</td></tr>
<tr class="memdesc:a3dfb6dea4a2bc13ede4e5b3dd87ada9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the maximum number of bytes in a received (but unwanted) body that will be skipped past, in order to reset to a new request.  <br /></td></tr>
<tr class="separator:a3dfb6dea4a2bc13ede4e5b3dd87ada9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5e1edb899e7b2642097e2fd641f879" id="r_aab5e1edb899e7b2642097e2fd641f879"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab5e1edb899e7b2642097e2fd641f879">willCloseConnection</a> ()</td></tr>
<tr class="memdesc:aab5e1edb899e7b2642097e2fd641f879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the server has indicated it will close the connection after this document has been read, or false if it will remain open (and future documents may be requested on the same connection).  <br /></td></tr>
<tr class="separator:aab5e1edb899e7b2642097e2fd641f879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4256380c28989809c969a89369f31a0c" id="r_a4256380c28989809c969a89369f31a0c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4256380c28989809c969a89369f31a0c">writeHeaders</a> (<a class="el" href="classpanda3d_1_1core_1_1Ostream.html">Ostream</a> out)</td></tr>
<tr class="memdesc:a4256380c28989809c969a89369f31a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a list of all headers defined by the server to the indicated output stream.  <br /></td></tr>
<tr class="separator:a4256380c28989809c969a89369f31a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpanda3d_1_1core_1_1TypedObject"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classpanda3d_1_1core_1_1TypedObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpanda3d_1_1core_1_1TypedObject.html">TypedObject</a></td></tr>
<tr class="memitem:a448a9aa2f31a7ae42ba0c6f43df3802a inherit pub_methods_classpanda3d_1_1core_1_1TypedObject" id="r_a448a9aa2f31a7ae42ba0c6f43df3802a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpanda3d_1_1core_1_1TypeHandle.html">TypeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1TypedObject.html#a448a9aa2f31a7ae42ba0c6f43df3802a">getType</a> ()</td></tr>
<tr class="separator:a448a9aa2f31a7ae42ba0c6f43df3802a inherit pub_methods_classpanda3d_1_1core_1_1TypedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ba0b9e444a3b2ba45a45be4c5140b7 inherit pub_methods_classpanda3d_1_1core_1_1TypedObject" id="r_aa3ba0b9e444a3b2ba45a45be4c5140b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1TypedObject.html#aa3ba0b9e444a3b2ba45a45be4c5140b7">getTypeIndex</a> ()</td></tr>
<tr class="memdesc:aa3ba0b9e444a3b2ba45a45be4c5140b7 inherit pub_methods_classpanda3d_1_1core_1_1TypedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal index number associated with this object's <a class="el" href="classpanda3d_1_1core_1_1TypeHandle.html" title="TypeHandle is the identifier used to differentiate C++ class types.">TypeHandle</a>, a unique number for each different type.  <br /></td></tr>
<tr class="separator:aa3ba0b9e444a3b2ba45a45be4c5140b7 inherit pub_methods_classpanda3d_1_1core_1_1TypedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3976e9b65bce46eab12354fba8ba33dd inherit pub_methods_classpanda3d_1_1core_1_1TypedObject" id="r_a3976e9b65bce46eab12354fba8ba33dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1TypedObject.html#a3976e9b65bce46eab12354fba8ba33dd">isExactType</a> (<a class="el" href="classpanda3d_1_1core_1_1TypeHandle.html">TypeHandle</a> handle)</td></tr>
<tr class="memdesc:a3976e9b65bce46eab12354fba8ba33dd inherit pub_methods_classpanda3d_1_1core_1_1TypedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the current object is the indicated type exactly.  <br /></td></tr>
<tr class="separator:a3976e9b65bce46eab12354fba8ba33dd inherit pub_methods_classpanda3d_1_1core_1_1TypedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9546e79ea7c26e6883b83e3afe87587f inherit pub_methods_classpanda3d_1_1core_1_1TypedObject" id="r_a9546e79ea7c26e6883b83e3afe87587f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1TypedObject.html#a9546e79ea7c26e6883b83e3afe87587f">isOfType</a> (<a class="el" href="classpanda3d_1_1core_1_1TypeHandle.html">TypeHandle</a> handle)</td></tr>
<tr class="memdesc:a9546e79ea7c26e6883b83e3afe87587f inherit pub_methods_classpanda3d_1_1core_1_1TypedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the current object is or derives from the indicated type.  <br /></td></tr>
<tr class="separator:a9546e79ea7c26e6883b83e3afe87587f inherit pub_methods_classpanda3d_1_1core_1_1TypedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classpanda3d_1_1core_1_1ReferenceCount')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html">ReferenceCount</a></td></tr>
<tr class="memitem:a6c336617bdadf1660f079d3ceacf48bf inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount" id="r_a6c336617bdadf1660f079d3ceacf48bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a6c336617bdadf1660f079d3ceacf48bf">getRefCount</a> ()</td></tr>
<tr class="memdesc:a6c336617bdadf1660f079d3ceacf48bf inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current reference count.  <br /></td></tr>
<tr class="separator:a6c336617bdadf1660f079d3ceacf48bf inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895fd31ef3cb5add22a875fc9e5bee19 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount" id="r_a895fd31ef3cb5add22a875fc9e5bee19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a895fd31ef3cb5add22a875fc9e5bee19">ref</a> ()</td></tr>
<tr class="memdesc:a895fd31ef3cb5add22a875fc9e5bee19 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly increments the reference count.  <br /></td></tr>
<tr class="separator:a895fd31ef3cb5add22a875fc9e5bee19 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4e39df87bae0b1121681eb5e725812 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount" id="r_a8d4e39df87bae0b1121681eb5e725812"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a8d4e39df87bae0b1121681eb5e725812">testRefCountIntegrity</a> ()</td></tr>
<tr class="memdesc:a8d4e39df87bae0b1121681eb5e725812 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does some easy checks to make sure that the reference count isn't completely bogus.  <br /></td></tr>
<tr class="separator:a8d4e39df87bae0b1121681eb5e725812 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70436632764926b0453751c516623065 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount" id="r_a70436632764926b0453751c516623065"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a70436632764926b0453751c516623065">testRefCountNonzero</a> ()</td></tr>
<tr class="memdesc:a70436632764926b0453751c516623065 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does some easy checks to make sure that the reference count isn't zero, or completely bogus.  <br /></td></tr>
<tr class="separator:a70436632764926b0453751c516623065 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedee0f893c0e1766f4a89c544eec5c02 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount" id="r_aedee0f893c0e1766f4a89c544eec5c02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#aedee0f893c0e1766f4a89c544eec5c02">unref</a> ()</td></tr>
<tr class="memdesc:aedee0f893c0e1766f4a89c544eec5c02 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly decrements the reference count.  <br /></td></tr>
<tr class="separator:aedee0f893c0e1766f4a89c544eec5c02 inherit pub_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6ee74ed0904ab08032e044c5bea991dc" id="r_a6ee74ed0904ab08032e044c5bea991dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpanda3d_1_1core_1_1TypeHandle.html">TypeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ee74ed0904ab08032e044c5bea991dc">getClassType</a> ()</td></tr>
<tr class="separator:a6ee74ed0904ab08032e044c5bea991dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classpanda3d_1_1core_1_1TypedReferenceCount"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_classpanda3d_1_1core_1_1TypedReferenceCount')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classpanda3d_1_1core_1_1TypedReferenceCount.html">TypedReferenceCount</a></td></tr>
<tr class="memitem:a6ee74ed0904ab08032e044c5bea991dc inherit pub_static_methods_classpanda3d_1_1core_1_1TypedReferenceCount" id="r_a6ee74ed0904ab08032e044c5bea991dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpanda3d_1_1core_1_1TypeHandle.html">TypeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1TypedReferenceCount.html#a6ee74ed0904ab08032e044c5bea991dc">getClassType</a> ()</td></tr>
<tr class="separator:a6ee74ed0904ab08032e044c5bea991dc inherit pub_static_methods_classpanda3d_1_1core_1_1TypedReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classpanda3d_1_1core_1_1TypedObject"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_classpanda3d_1_1core_1_1TypedObject')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classpanda3d_1_1core_1_1TypedObject.html">TypedObject</a></td></tr>
<tr class="memitem:a6ee74ed0904ab08032e044c5bea991dc inherit pub_static_methods_classpanda3d_1_1core_1_1TypedObject" id="r_a6ee74ed0904ab08032e044c5bea991dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpanda3d_1_1core_1_1TypeHandle.html">TypeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1TypedObject.html#a6ee74ed0904ab08032e044c5bea991dc">getClassType</a> ()</td></tr>
<tr class="separator:a6ee74ed0904ab08032e044c5bea991dc inherit pub_static_methods_classpanda3d_1_1core_1_1TypedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classpanda3d_1_1core_1_1ReferenceCount"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_classpanda3d_1_1core_1_1ReferenceCount')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html">ReferenceCount</a></td></tr>
<tr class="memitem:a6ee74ed0904ab08032e044c5bea991dc inherit pub_static_methods_classpanda3d_1_1core_1_1ReferenceCount" id="r_a6ee74ed0904ab08032e044c5bea991dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpanda3d_1_1core_1_1TypeHandle.html">TypeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a6ee74ed0904ab08032e044c5bea991dc">getClassType</a> ()</td></tr>
<tr class="separator:a6ee74ed0904ab08032e044c5bea991dc inherit pub_static_methods_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_classpanda3d_1_1core_1_1TypedObject"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_attribs_classpanda3d_1_1core_1_1TypedObject')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classpanda3d_1_1core_1_1TypedObject.html">TypedObject</a></td></tr>
<tr class="memitem:adcb5439765fa1e588bba2ec63e2c6ff7 inherit pub_attribs_classpanda3d_1_1core_1_1TypedObject" id="r_adcb5439765fa1e588bba2ec63e2c6ff7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpanda3d_1_1core_1_1TypeHandle.html">TypeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1TypedObject.html#adcb5439765fa1e588bba2ec63e2c6ff7">type</a></td></tr>
<tr class="memdesc:adcb5439765fa1e588bba2ec63e2c6ff7 inherit pub_attribs_classpanda3d_1_1core_1_1TypedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classpanda3d_1_1core_1_1TypeHandle.html" title="TypeHandle is the identifier used to differentiate C++ class types.">TypeHandle</a> representing this object's type.  <br /></td></tr>
<tr class="separator:adcb5439765fa1e588bba2ec63e2c6ff7 inherit pub_attribs_classpanda3d_1_1core_1_1TypedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classpanda3d_1_1core_1_1ReferenceCount"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_attribs_classpanda3d_1_1core_1_1ReferenceCount')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html">ReferenceCount</a></td></tr>
<tr class="memitem:a223a278e0bf3b42ae887efe07bfbeac0 inherit pub_attribs_classpanda3d_1_1core_1_1ReferenceCount" id="r_a223a278e0bf3b42ae887efe07bfbeac0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpanda3d_1_1core_1_1ReferenceCount.html#a223a278e0bf3b42ae887efe07bfbeac0">ref_count</a></td></tr>
<tr class="memdesc:a223a278e0bf3b42ae887efe07bfbeac0 inherit pub_attribs_classpanda3d_1_1core_1_1ReferenceCount"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current reference count.  <br /></td></tr>
<tr class="separator:a223a278e0bf3b42ae887efe07bfbeac0 inherit pub_attribs_classpanda3d_1_1core_1_1ReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A single channel of communication from an <a class="el" href="classpanda3d_1_1core_1_1HTTPClient.html" title="Handles contacting an HTTP server and retrieving a document.">HTTPClient</a>. </p>
<p>This is similar to the concept of a 'connection', except that HTTP is technically connectionless; in fact, a channel may represent one unbroken connection or it may transparently close and reopen a new connection with each request.</p>
<p>A channel is conceptually a single thread of I/O. One document at a time may be requested using a channel; a new document may (in general) not be requested from the same <a class="el" href="classpanda3d_1_1core_1_1HTTPChannel.html" title="A single channel of communication from an HTTPClient.">HTTPChannel</a> until the first document has been fully retrieved. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ae98a46f4ea1a43ca48acaf15d2eb7113" name="ae98a46f4ea1a43ca48acaf15d2eb7113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98a46f4ea1a43ca48acaf15d2eb7113">&#9670;&#160;</a></span>StatusCode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ae98a46f4ea1a43ca48acaf15d2eb7113">StatusCode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113ab6199f85d54c8d0b26e07dbd928cbd34" name="ae98a46f4ea1a43ca48acaf15d2eb7113ab6199f85d54c8d0b26e07dbd928cbd34"></a>SC_incomplete&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113ab523f677e7fd8cff192876182c6894bf" name="ae98a46f4ea1a43ca48acaf15d2eb7113ab523f677e7fd8cff192876182c6894bf"></a>SC_internal_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113ad2af2837621278bca55512447cad85a1" name="ae98a46f4ea1a43ca48acaf15d2eb7113ad2af2837621278bca55512447cad85a1"></a>SC_no_connection&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113a958d63ae52623c2eb8a6c32ba08d5e95" name="ae98a46f4ea1a43ca48acaf15d2eb7113a958d63ae52623c2eb8a6c32ba08d5e95"></a>SC_timeout&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113a6aceee3ad9c49e5f9ea67721afc8f191" name="ae98a46f4ea1a43ca48acaf15d2eb7113a6aceee3ad9c49e5f9ea67721afc8f191"></a>SC_lost_connection&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113a1b0b94ee206270e80c5be752a0fd7c5e" name="ae98a46f4ea1a43ca48acaf15d2eb7113a1b0b94ee206270e80c5be752a0fd7c5e"></a>SC_non_http_response&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113ac5b296164b82ff5332337570fccde466" name="ae98a46f4ea1a43ca48acaf15d2eb7113ac5b296164b82ff5332337570fccde466"></a>SC_invalid_http&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113aa8b6454880e0abc5aa1694b6ce2695d7" name="ae98a46f4ea1a43ca48acaf15d2eb7113aa8b6454880e0abc5aa1694b6ce2695d7"></a>SC_socks_invalid_version&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113a1e1e4dd0f5ba15095cc9df3e55ff49fa" name="ae98a46f4ea1a43ca48acaf15d2eb7113a1e1e4dd0f5ba15095cc9df3e55ff49fa"></a>SC_socks_no_acceptable_login_method&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113ab01dd6595b408e3efe8382ccb7da33a1" name="ae98a46f4ea1a43ca48acaf15d2eb7113ab01dd6595b408e3efe8382ccb7da33a1"></a>SC_socks_refused&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113ac928b46da2455e3126f06e6d66958feb" name="ae98a46f4ea1a43ca48acaf15d2eb7113ac928b46da2455e3126f06e6d66958feb"></a>SC_socks_no_connection&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113a52f7e6e185ae0618bde0564546907f66" name="ae98a46f4ea1a43ca48acaf15d2eb7113a52f7e6e185ae0618bde0564546907f66"></a>SC_ssl_internal_failure&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113a8db172b55bd79efe9ff89b134a419070" name="ae98a46f4ea1a43ca48acaf15d2eb7113a8db172b55bd79efe9ff89b134a419070"></a>SC_ssl_no_handshake&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113aa6c9041771b15e224e88c1c5f5151e65" name="ae98a46f4ea1a43ca48acaf15d2eb7113aa6c9041771b15e224e88c1c5f5151e65"></a>SC_http_error_watermark&#160;</td><td class="fielddoc"><p>No one returns this code, but StatusCode values higher than this are deemed more successful than any generic HTTP response. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113a984b9757941eafb88f257a00c3e28353" name="ae98a46f4ea1a43ca48acaf15d2eb7113a984b9757941eafb88f257a00c3e28353"></a>SC_ssl_invalid_server_certificate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113acb64a6045d6e401d8b1d93d8eb6ff20f" name="ae98a46f4ea1a43ca48acaf15d2eb7113acb64a6045d6e401d8b1d93d8eb6ff20f"></a>SC_ssl_self_signed_server_certificate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113afe02f7b9ccfdf9550211b599784e4389" name="ae98a46f4ea1a43ca48acaf15d2eb7113afe02f7b9ccfdf9550211b599784e4389"></a>SC_ssl_unexpected_server&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113a025f16bf0178b2c21b2d8ee2553641c7" name="ae98a46f4ea1a43ca48acaf15d2eb7113a025f16bf0178b2c21b2d8ee2553641c7"></a>SC_download_open_error&#160;</td><td class="fielddoc"><p>These errors are only generated after a download_to_*() call been issued. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113a8c43a2b2e86d9c55ad30c8e54cc2bee7" name="ae98a46f4ea1a43ca48acaf15d2eb7113a8c43a2b2e86d9c55ad30c8e54cc2bee7"></a>SC_download_write_error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae98a46f4ea1a43ca48acaf15d2eb7113a7f28c465126b4084b360e2b8aee4e316" name="ae98a46f4ea1a43ca48acaf15d2eb7113a7f28c465126b4084b360e2b8aee4e316"></a>SC_download_invalid_range&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac9b8f0cacbce0fcebb71797390c6132b" name="ac9b8f0cacbce0fcebb71797390c6132b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b8f0cacbce0fcebb71797390c6132b">&#9670;&#160;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__init__ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1HTTPChannel.html">HTTPChannel</a></td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac3e5ac7e5658df540f619452d82a403" name="aac3e5ac7e5658df540f619452d82a403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3e5ac7e5658df540f619452d82a403">&#9670;&#160;</a></span>beginConnectTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">beginConnectTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a></td>          <td class="paramname"><span class="paramname"><em>url</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins a non-blocking request to establish a direct connection to the server and port indicated by the URL. </p>
<p>No HTTP requests will be issued beyond what is necessary to establish the connection. When <a class="el" href="#a149ad6701e3e2414cb566bb414029841" title="This must be called from time to time when non-blocking I/O is in use.">run()</a> has finished, you may call is_connection_ready() to determine if the connection was successfully established.</p>
<p>If successful, the connection may then be taken to use for whatever purposes you like by calling get_connection().</p>
<p>This establishes a nonblocking I/O socket. Also see connect_to(). </p>

</div>
</div>
<a id="a9e528d05784a9a63bcc91496e1d66784" name="a9e528d05784a9a63bcc91496e1d66784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e528d05784a9a63bcc91496e1d66784">&#9670;&#160;</a></span>beginGetDocument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">beginGetDocument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a></td>          <td class="paramname"><span class="paramname"><em>url</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins a non-blocking request to retrieve a given document. </p>
<p>This method will return immediately, even before a connection to the server has necessarily been established; you must then call <a class="el" href="#a149ad6701e3e2414cb566bb414029841" title="This must be called from time to time when non-blocking I/O is in use.">run()</a> from time to time until the return value of <a class="el" href="#a149ad6701e3e2414cb566bb414029841" title="This must be called from time to time when non-blocking I/O is in use.">run()</a> is false. Then you may check is_valid() and get_status_code() to determine the status of your request.</p>
<p>If a previous request had been pending, that request is discarded. </p>

</div>
</div>
<a id="a7677d757ac25d89fa5ab5972306ab5b5" name="a7677d757ac25d89fa5ab5972306ab5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7677d757ac25d89fa5ab5972306ab5b5">&#9670;&#160;</a></span>beginGetHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">beginGetHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a></td>          <td class="paramname"><span class="paramname"><em>url</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins a non-blocking request to retrieve a given header. </p>
<p>See begin_get_document() and get_header(). </p>

</div>
</div>
<a id="aac7680669b3c64515454d28151c82177" name="aac7680669b3c64515454d28151c82177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7680669b3c64515454d28151c82177">&#9670;&#160;</a></span>beginGetSubdocument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">beginGetSubdocument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a></td>          <td class="paramname"><span class="paramname"><em>url</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>first_byte</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>last_byte</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins a non-blocking request to retrieve only the specified byte range of the indicated document. </p>
<p>If last_byte is 0, it stands for the last byte of the document. When a subdocument is requested, get_file_size() and get_bytes_downloaded() will report the number of bytes of the subdocument, not of the complete document. </p>

</div>
</div>
<a id="aa42e4c6ba72f46d4c050e1739890f474" name="aa42e4c6ba72f46d4c050e1739890f474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42e4c6ba72f46d4c050e1739890f474">&#9670;&#160;</a></span>beginPostForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">beginPostForm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a></td>          <td class="paramname"><span class="paramname"><em>url</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>body</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts form data to a particular URL and retrieves the response, all using non-blocking I/O. </p>
<p>See begin_get_document() and post_form().</p>
<p>It is important to note that you <em>must</em> call <a class="el" href="#a149ad6701e3e2414cb566bb414029841" title="This must be called from time to time when non-blocking I/O is in use.">run()</a> repeatedly after calling this method until <a class="el" href="#a149ad6701e3e2414cb566bb414029841" title="This must be called from time to time when non-blocking I/O is in use.">run()</a> returns false, and you may not call any other document posting or retrieving methods using the <a class="el" href="classpanda3d_1_1core_1_1HTTPChannel.html" title="A single channel of communication from an HTTPClient.">HTTPChannel</a> object in the interim, or your form data may not get posted. </p>

</div>
</div>
<a id="aed8cb8cab06d2e0cfe049d801bea640a" name="aed8cb8cab06d2e0cfe049d801bea640a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8cb8cab06d2e0cfe049d801bea640a">&#9670;&#160;</a></span>clearExtraHeaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">clearExtraHeaders </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the extra headers that were previously added via calls to send_extra_header(). </p>

</div>
</div>
<a id="af1f66f14b00534e51c55887fbedc40fb" name="af1f66f14b00534e51c55887fbedc40fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f66f14b00534e51c55887fbedc40fb">&#9670;&#160;</a></span>closeReadBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">closeReadBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Istream.html">Istream</a></td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes a file opened by a previous call to open_read_body(). </p>
<p>This really just deletes the istream pointer, but it is recommended to use this interface instead of deleting it explicitly, to help work around compiler issues. </p>

</div>
</div>
<a id="a8ca6b206155cddaf3655622c6fd048a6" name="a8ca6b206155cddaf3655622c6fd048a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca6b206155cddaf3655622c6fd048a6">&#9670;&#160;</a></span>connectTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool connectTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a></td>          <td class="paramname"><span class="paramname"><em>url</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establish a direct connection to the server and port indicated by the URL, but do not issue any HTTP requests. </p>
<p>If successful, the connection may then be taken to use for whatever purposes you like by calling get_connection().</p>
<p>This establishes a blocking I/O socket. Also see begin_connect_to(). </p>

</div>
</div>
<a id="a9fa49da0e2300a67310986c2ee849576" name="a9fa49da0e2300a67310986c2ee849576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa49da0e2300a67310986c2ee849576">&#9670;&#160;</a></span>deleteDocument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool deleteDocument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a></td>          <td class="paramname"><span class="paramname"><em>url</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests the server to remove the indicated URL. </p>

</div>
</div>
<a id="a52f0f7dc80424eb3d3302d9a78dfdddd" name="a52f0f7dc80424eb3d3302d9a78dfdddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f0f7dc80424eb3d3302d9a78dfdddd">&#9670;&#160;</a></span>downloadToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool downloadToFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1Filename.html">Filename</a></td>          <td class="paramname"><span class="paramname"><em>filename</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>subdocument_resumes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the name of a file to download the resulting document to. </p>
<p>This should be called immediately after get_document() or begin_get_document() or related functions.</p>
<p>In the case of the blocking I/O methods like get_document(), this function will download the entire document to the file and return true if it was successfully downloaded, false otherwise.</p>
<p>In the case of non-blocking I/O methods like begin_get_document(), this function simply indicates an intention to download to the indicated file. It returns true if the file can be opened for writing, false otherwise, but the contents will not be completely downloaded until <a class="el" href="#a149ad6701e3e2414cb566bb414029841" title="This must be called from time to time when non-blocking I/O is in use.">run()</a> has returned false. At this time, it is possible that a communications error will have left a partial file, so is_download_complete() may be called to test this.</p>
<p>If subdocument_resumes is true and the document in question was previously requested as a subdocument (i.e. get_subdocument() with a first_byte value greater than zero), this will automatically seek to the appropriate byte within the file for writing the output. In this case, the file must already exist and must have at least first_byte bytes in it. If subdocument_resumes is false, a subdocument will always be downloaded beginning at the first byte of the file. </p>

</div>
</div>
<a id="a79f25f1525d04bd5cebf77442548760f" name="a79f25f1525d04bd5cebf77442548760f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f25f1525d04bd5cebf77442548760f">&#9670;&#160;</a></span>downloadToRam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool downloadToRam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Ramfile.html">Ramfile</a></td>          <td class="paramname"><span class="paramname"><em>ramfile</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>subdocument_resumes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies a <a class="el" href="classpanda3d_1_1core_1_1Ramfile.html" title="An in-memory buffer specifically designed for downloading files to memory.">Ramfile</a> object to download the resulting document to. </p>
<p>This should be called immediately after get_document() or begin_get_document() or related functions.</p>
<p>In the case of the blocking I/O methods like get_document(), this function will download the entire document to the <a class="el" href="classpanda3d_1_1core_1_1Ramfile.html" title="An in-memory buffer specifically designed for downloading files to memory.">Ramfile</a> and return true if it was successfully downloaded, false otherwise.</p>
<p>In the case of non-blocking I/O methods like begin_get_document(), this function simply indicates an intention to download to the indicated <a class="el" href="classpanda3d_1_1core_1_1Ramfile.html" title="An in-memory buffer specifically designed for downloading files to memory.">Ramfile</a>. It returns true if the file can be opened for writing, false otherwise, but the contents will not be completely downloaded until <a class="el" href="#a149ad6701e3e2414cb566bb414029841" title="This must be called from time to time when non-blocking I/O is in use.">run()</a> has returned false. At this time, it is possible that a communications error will have left a partial file, so is_download_complete() may be called to test this.</p>
<p>If subdocument_resumes is true and the document in question was previously requested as a subdocument (i.e. get_subdocument() with a first_byte value greater than zero), this will automatically seek to the appropriate byte within the <a class="el" href="classpanda3d_1_1core_1_1Ramfile.html" title="An in-memory buffer specifically designed for downloading files to memory.">Ramfile</a> for writing the output. In this case, the <a class="el" href="classpanda3d_1_1core_1_1Ramfile.html" title="An in-memory buffer specifically designed for downloading files to memory.">Ramfile</a> must already have at least first_byte bytes in it. </p>

</div>
</div>
<a id="a083637ffe516232465c6fe3efc299417" name="a083637ffe516232465c6fe3efc299417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083637ffe516232465c6fe3efc299417">&#9670;&#160;</a></span>downloadToStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool downloadToStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Ostream.html">Ostream</a></td>          <td class="paramname"><span class="paramname"><em>strm</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>subdocument_resumes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the name of an ostream to download the resulting document to. </p>
<p>This should be called immediately after get_document() or begin_get_document() or related functions.</p>
<p>In the case of the blocking I/O methods like get_document(), this function will download the entire document to the file and return true if it was successfully downloaded, false otherwise.</p>
<p>In the case of non-blocking I/O methods like begin_get_document(), this function simply indicates an intention to download to the indicated file. It returns true if the file can be opened for writing, false otherwise, but the contents will not be completely downloaded until <a class="el" href="#a149ad6701e3e2414cb566bb414029841" title="This must be called from time to time when non-blocking I/O is in use.">run()</a> has returned false. At this time, it is possible that a communications error will have left a partial file, so is_download_complete() may be called to test this.</p>
<p>If subdocument_resumes is true and the document in question was previously requested as a subdocument (i.e. get_subdocument() with a first_byte value greater than zero), this will automatically seek to the appropriate byte within the file for writing the output. In this case, the file must already exist and must have at least first_byte bytes in it. If subdocument_resumes is false, a subdocument will always be downloaded beginning at the first byte of the file. </p>

</div>
</div>
<a id="a8e27a1fd3f1944699a1f5939d4d80e43" name="a8e27a1fd3f1944699a1f5939d4d80e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e27a1fd3f1944699a1f5939d4d80e43">&#9670;&#160;</a></span>getAllowProxy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getAllowProxy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If this is true (the normal case), the <a class="el" href="classpanda3d_1_1core_1_1HTTPClient.html" title="Handles contacting an HTTP server and retrieving a document.">HTTPClient</a> will be consulted for information about the proxy to be used for each connection via this <a class="el" href="classpanda3d_1_1core_1_1HTTPChannel.html" title="A single channel of communication from an HTTPClient.">HTTPChannel</a>. </p>
<p>If this has been set to false by the user, then all connections will be made directly, regardless of the proxy settings indicated on the <a class="el" href="classpanda3d_1_1core_1_1HTTPClient.html" title="Handles contacting an HTTP server and retrieving a document.">HTTPClient</a>. </p>

</div>
</div>
<a id="a34d90f3382d6b8afd16a5fcbd953680e" name="a34d90f3382d6b8afd16a5fcbd953680e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d90f3382d6b8afd16a5fcbd953680e">&#9670;&#160;</a></span>getBlockingConnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getBlockingConnect </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If this flag is true, a socket connect will block even for nonblocking I/O calls like begin_get_document(), begin_connect_to(), etc. </p>
<p>If false, a socket connect will not block for nonblocking I/O calls, but will block for blocking I/O calls (get_document(), connect_to(), etc.). </p>

</div>
</div>
<a id="a2743a7c6237af60561d6a5680c792e2e" name="a2743a7c6237af60561d6a5680c792e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2743a7c6237af60561d6a5680c792e2e">&#9670;&#160;</a></span>getBytesDownloaded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getBytesDownloaded </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bytes downloaded during the last (or current) download_to_file() or download_to_ram operation(). </p>
<p>This can be used in conjunction with get_file_size() to report the percent complete (but be careful, since get_file_size() may return 0 if the server has not told us the size of the file). </p>

</div>
</div>
<a id="ae27005d4997e152957c7d688a1d110e5" name="ae27005d4997e152957c7d688a1d110e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27005d4997e152957c7d688a1d110e5">&#9670;&#160;</a></span>getBytesRequested()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getBytesRequested </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When download throttling is in effect (set_download_throttle() has been set to true) and non-blocking I/O methods (like begin_get_document()) are used, this returns the number of bytes "requested" from the server so far: that is, the theoretical maximum value for get_bytes_downloaded(), if the server has been keeping up with our demand. </p>
<p>If this number is less than get_bytes_downloaded(), then the server has not been supplying bytes fast enough to meet our own download throttle rate.</p>
<p>When download throttling is not in effect, or when the blocking I/O methods (like get_document(), etc.) are used, this returns 0. </p>

</div>
</div>
<a id="a6ee74ed0904ab08032e044c5bea991dc" name="a6ee74ed0904ab08032e044c5bea991dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee74ed0904ab08032e044c5bea991dc">&#9670;&#160;</a></span>getClassType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpanda3d_1_1core_1_1TypeHandle.html">TypeHandle</a> getClassType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1814c41daa359139ce416e11b648fdb6" name="a1814c41daa359139ce416e11b648fdb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1814c41daa359139ce416e11b648fdb6">&#9670;&#160;</a></span>getClient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpanda3d_1_1core_1_1HTTPClient.html">HTTPClient</a> getClient </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classpanda3d_1_1core_1_1HTTPClient.html" title="Handles contacting an HTTP server and retrieving a document.">HTTPClient</a> object that owns this channel. </p>

</div>
</div>
<a id="a5c50ab742c0dae90289475d234d93b01" name="a5c50ab742c0dae90289475d234d93b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c50ab742c0dae90289475d234d93b01">&#9670;&#160;</a></span>getConnection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpanda3d_1_1core_1_1SocketStream.html">SocketStream</a> getConnection </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the connection that was established via a previous call to connect_to() or begin_connect_to(), or NULL if the connection attempt failed or if those methods have not recently been called. </p>
<p>This stream has been allocated from the free store. It is the user's responsibility to delete this pointer when finished with it. </p>

</div>
</div>
<a id="a24cf7db191a7c96c208d25af76a7a2f7" name="a24cf7db191a7c96c208d25af76a7a2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24cf7db191a7c96c208d25af76a7a2f7">&#9670;&#160;</a></span>getConnectTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double getConnectTimeout </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of time, in seconds, to wait for a new nonblocking socket to connect. </p>
<p>See set_connect_timeout(). </p>

</div>
</div>
<a id="a9fa055f565e51ae55f654beec638b544" name="a9fa055f565e51ae55f654beec638b544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa055f565e51ae55f654beec638b544">&#9670;&#160;</a></span>getContentType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str getContentType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the Content-Type header. </p>

</div>
</div>
<a id="ad3f4f65e5b313777916347b6e0855615" name="ad3f4f65e5b313777916347b6e0855615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f4f65e5b313777916347b6e0855615">&#9670;&#160;</a></span>getDocument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getDocument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a></td>          <td class="paramname"><span class="paramname"><em>url</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens the named document for reading, if available. </p>
<p>Returns true if successful, false otherwise. </p>

</div>
</div>
<a id="a9ee356412ab38659490fbfaedf153a26" name="a9ee356412ab38659490fbfaedf153a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee356412ab38659490fbfaedf153a26">&#9670;&#160;</a></span>getDocumentSpec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a> getDocumentSpec </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html" title="A descriptor that refers to a particular version of a document.">DocumentSpec</a> associated with the most recent document. </p>
<p>This includes its actual URL (following redirects) along with the identity tag and last-modified date, if supplied by the server.</p>
<p>This structure may be saved and used to retrieve the same version of the document later, or to conditionally retrieve a newer version if it is available. </p>

</div>
</div>
<a id="a55465a200cc0b6ad65124d80fbd4cd62" name="a55465a200cc0b6ad65124d80fbd4cd62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55465a200cc0b6ad65124d80fbd4cd62">&#9670;&#160;</a></span>getDownloadThrottle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getDownloadThrottle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the nonblocking downloads will be bandwidth-limited. </p>
<p>See set_download_throttle(). </p>

</div>
</div>
<a id="a86c163af5216d2dbf340689aa40b9dcf" name="a86c163af5216d2dbf340689aa40b9dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c163af5216d2dbf340689aa40b9dcf">&#9670;&#160;</a></span>getFileSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Streamsize getFileSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the file, if it is known. </p>
<p>Returns the value set by set_expected_file_size() if the file size is not known, or 0 if this value was not set.</p>
<p>If the file is dynamically generated, the size may not be available until a read has started (e.g. open_read_body() has been called); and even then it may increase as more of the file is read due to the nature of HTTP/1.1 requests which can change their minds midstream about how much data they're sending you. </p>

</div>
</div>
<a id="afc7acf4faafdfef0d97de3df498ea963" name="afc7acf4faafdfef0d97de3df498ea963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7acf4faafdfef0d97de3df498ea963">&#9670;&#160;</a></span>getFirstByteDelivered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getFirstByteDelivered </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first byte of the file (that will be) delivered by the server in response to the current request. </p>
<p>Normally, this is the same as get_first_byte_requested(), but some servers will ignore a subdocument request and always return the whole file, in which case this value will be 0, regardless of what was requested to get_subdocument(). </p>

</div>
</div>
<a id="aafe9f83aaa816dd67173ee267ff36ac6" name="aafe9f83aaa816dd67173ee267ff36ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe9f83aaa816dd67173ee267ff36ac6">&#9670;&#160;</a></span>getFirstByteRequested()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getFirstByteRequested </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first byte of the file requested by the request. </p>
<p>This will normally be 0 to indicate that the file is being requested from the beginning, but if the file was requested via a get_subdocument() call, this will contain the first_byte parameter from that call. </p>

</div>
</div>
<a id="ac157ba4dedb265f111630b2576e6a6cd" name="ac157ba4dedb265f111630b2576e6a6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac157ba4dedb265f111630b2576e6a6cd">&#9670;&#160;</a></span>getHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getHeader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a></td>          <td class="paramname"><span class="paramname"><em>url</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like get_document(), except only the header associated with the document is retrieved. </p>
<p>This may be used to test for existence of the document; it might also return the size of the document (if the server gives us this information). </p>

</div>
</div>
<a id="abfa3dee8ab5f1c1d4b2e9c0e5a558a18" name="abfa3dee8ab5f1c1d4b2e9c0e5a558a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa3dee8ab5f1c1d4b2e9c0e5a558a18">&#9670;&#160;</a></span>getHeaderValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str getHeaderValue </td>
          <td>(</td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the HTML header value associated with the indicated key, or empty string if the key was not defined in the message returned by the server. </p>

</div>
</div>
<a id="a10ac7b91b85bece2d51ae6bcc525fa1d" name="a10ac7b91b85bece2d51ae6bcc525fa1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ac7b91b85bece2d51ae6bcc525fa1d">&#9670;&#160;</a></span>getHttpTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double getHttpTimeout </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of time, in seconds, to wait for the HTTP server to respond to our request. </p>
<p>See set_http_timeout(). </p>

</div>
</div>
<a id="aaea6c8f763b89c04ad030eb53b94e422" name="aaea6c8f763b89c04ad030eb53b94e422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea6c8f763b89c04ad030eb53b94e422">&#9670;&#160;</a></span>getHttpVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpanda3d_1_1core_1_1HTTPEnum.html#abe818f5ff14e9c60c052a3e96877cec6">HTTPEnum::HTTPVersion</a> getHttpVersion </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the HTTP version number returned by the server, as one of the <a class="el" href="classpanda3d_1_1core_1_1HTTPClient.html" title="Handles contacting an HTTP server and retrieving a document.">HTTPClient</a> enumerated types, e.g. </p>
<p>HTTPClient::HV_11. </p>

</div>
</div>
<a id="a6e3a10a5fe1fc3d36b3c723629510981" name="a6e3a10a5fe1fc3d36b3c723629510981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3a10a5fe1fc3d36b3c723629510981">&#9670;&#160;</a></span>getHttpVersionString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str getHttpVersionString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the HTTP version number returned by the server, formatted as a string, e.g. </p>
<p>"HTTP/1.1". </p>

</div>
</div>
<a id="af1851c6ae5648db0ba73d7b3b000f5e5" name="af1851c6ae5648db0ba73d7b3b000f5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1851c6ae5648db0ba73d7b3b000f5e5">&#9670;&#160;</a></span>getIdleTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double getIdleTimeout </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of time, in seconds, in which an previously-established connection is allowed to remain open and unused. </p>
<p>See set_idle_timeout(). </p>

</div>
</div>
<a id="a556644d6e27eb09ae78c460ede06aa35" name="a556644d6e27eb09ae78c460ede06aa35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556644d6e27eb09ae78c460ede06aa35">&#9670;&#160;</a></span>getLastByteDelivered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getLastByteDelivered </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last byte of the file (that will be) delivered by the server in response to the current request. </p>
<p>Normally, this is the same as get_last_byte_requested(), but some servers will ignore a subdocument request and always return the whole file, in which case this value will be 0, regardless of what was requested to get_subdocument(). </p>

</div>
</div>
<a id="ad01ccc12644499a46da32911e38af4a8" name="ad01ccc12644499a46da32911e38af4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01ccc12644499a46da32911e38af4a8">&#9670;&#160;</a></span>getLastByteRequested()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getLastByteRequested </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the last byte of the file requested by the request. </p>
<p>This will normally be 0 to indicate that the file is being requested to its last byte, but if the file was requested via a get_subdocument() call, this will contain the last_byte parameter from that call. </p>

</div>
</div>
<a id="aa7df96a2b0b9b61d3012557ba9e803be" name="aa7df96a2b0b9b61d3012557ba9e803be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7df96a2b0b9b61d3012557ba9e803be">&#9670;&#160;</a></span>getMaxBytesPerSecond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double getMaxBytesPerSecond </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum number of bytes per second that may be consumed by this channel when get_download_throttle() is true. </p>

</div>
</div>
<a id="aa0437efb3dd7b49bffc503747bb9cd69" name="aa0437efb3dd7b49bffc503747bb9cd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0437efb3dd7b49bffc503747bb9cd69">&#9670;&#160;</a></span>getMaxUpdatesPerSecond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double getMaxUpdatesPerSecond </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum number of times per second that <a class="el" href="#a149ad6701e3e2414cb566bb414029841" title="This must be called from time to time when non-blocking I/O is in use.">run()</a> will do anything at all, when get_download_throttle() is true. </p>

</div>
</div>
<a id="a917e3d5361a473e626c901b22bcf2dc0" name="a917e3d5361a473e626c901b22bcf2dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917e3d5361a473e626c901b22bcf2dc0">&#9670;&#160;</a></span>getNumRedirectSteps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getNumRedirectSteps </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the document automatically followed one or more redirects, this will return the number of redirects that were automatically followed. </p>
<p>Use get_redirect_step() to retrieve each URL in sequence. </p>

</div>
</div>
<a id="adf22f98730e58cdae4030a01d363527a" name="adf22f98730e58cdae4030a01d363527a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf22f98730e58cdae4030a01d363527a">&#9670;&#160;</a></span>getOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getOptions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a></td>          <td class="paramname"><span class="paramname"><em>url</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an OPTIONS message to the server, which should query the available options, possibly in relation to a specified URL. </p>

</div>
</div>
<a id="a44632a2434ddce5cabbd908e41ea93ed" name="a44632a2434ddce5cabbd908e41ea93ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44632a2434ddce5cabbd908e41ea93ed">&#9670;&#160;</a></span>getPersistentConnection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getPersistentConnection </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the <a class="el" href="classpanda3d_1_1core_1_1HTTPChannel.html" title="A single channel of communication from an HTTPClient.">HTTPChannel</a> should try to keep the connection to the server open and reuse that connection for multiple documents, or whether it should close the connection and open a new one for each request. </p>
<p>See set_persistent_connection(). </p>

</div>
</div>
<a id="ab2863611391e1a4c28422881d64a1ce6" name="ab2863611391e1a4c28422881d64a1ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2863611391e1a4c28422881d64a1ce6">&#9670;&#160;</a></span>getProxyRealm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str getProxyRealm </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the document failed to connect because of a 407 (Proxy authorization required), this method will return the "realm" returned by the proxy. </p>
<p>This string may be presented to the user to request an associated username and password (which then should be stored in HTTPClient::set_username()). </p>

</div>
</div>
<a id="a0e861abd3c8d9118669724a6b54ff062" name="a0e861abd3c8d9118669724a6b54ff062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e861abd3c8d9118669724a6b54ff062">&#9670;&#160;</a></span>getProxyTunnel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getProxyTunnel </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if connections always tunnel through a proxy, or false (the normal case) if we allow the proxy to serve up documents. </p>
<p>See set_proxy_tunnel(). </p>

</div>
</div>
<a id="ac5e695514506a5bce4c8fc5ded777dab" name="ac5e695514506a5bce4c8fc5ded777dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e695514506a5bce4c8fc5ded777dab">&#9670;&#160;</a></span>getRedirect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpanda3d_1_1core_1_1URLSpec.html">URLSpec</a> getRedirect </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the document failed with a redirect code (300 series), this will generally contain the new URL the server wants us to try. </p>
<p>In many cases, the client will automatically follow redirects; if these are successful the client will return a successful code and get_redirect() will return empty, but get_url() will return the new, redirected URL. </p>

</div>
</div>
<a id="ad92cff8ae39be87fea641b79bf310a8e" name="ad92cff8ae39be87fea641b79bf310a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92cff8ae39be87fea641b79bf310a8e">&#9670;&#160;</a></span>getRedirectStep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpanda3d_1_1core_1_1URLSpec.html">URLSpec</a> getRedirectStep </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use in conjunction with get_num_redirect_steps() to extract the chain of URL's that the channel was automatically redirected through to arrive at the final document. </p>

</div>
</div>
<a id="a3366d1fd890cfc9c922ff43c67c49537" name="a3366d1fd890cfc9c922ff43c67c49537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3366d1fd890cfc9c922ff43c67c49537">&#9670;&#160;</a></span>getRedirectSteps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list getRedirectSteps </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc7de7300525ee8e94faaa3e1dc7fadd" name="adc7de7300525ee8e94faaa3e1dc7fadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7de7300525ee8e94faaa3e1dc7fadd">&#9670;&#160;</a></span>getSkipBodySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getSkipBodySize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum number of bytes in a received (but unwanted) body that will be skipped past, in order to reset to a new request. </p>
<p>See set_skip_body_size(). </p>

</div>
</div>
<a id="a328ca7b0d5e311df982f9d48d9724bb1" name="a328ca7b0d5e311df982f9d48d9724bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328ca7b0d5e311df982f9d48d9724bb1">&#9670;&#160;</a></span>getStatusCode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getStatusCode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the HTML return code from the document retrieval request. </p>
<p>This will be in the 200 range if the document is successfully retrieved, or some other value in the case of an error.</p>
<p>Some proxy errors during an https-over-proxy request would return the same status code as a different error that occurred on the host server. To differentiate these cases, status codes that are returned by the proxy during the CONNECT phase (except code 407) are incremented by 1000. </p>

</div>
</div>
<a id="ae3c48f33ee430194f7d0e16d948a44cc" name="ae3c48f33ee430194f7d0e16d948a44cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c48f33ee430194f7d0e16d948a44cc">&#9670;&#160;</a></span>getStatusString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str getStatusString </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the string as returned by the server describing the status code for humans. </p>
<p>This may or may not be meaningful. </p>

</div>
</div>
<a id="a69a199930b7b8584bf3d25c08c2834d3" name="a69a199930b7b8584bf3d25c08c2834d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a199930b7b8584bf3d25c08c2834d3">&#9670;&#160;</a></span>getSubdocument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getSubdocument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a></td>          <td class="paramname"><span class="paramname"><em>url</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>first_byte</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>last_byte</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves only the specified byte range of the indicated document. </p>
<p>If last_byte is 0, it stands for the last byte of the document. When a subdocument is requested, get_file_size() and get_bytes_downloaded() will report the number of bytes of the subdocument, not of the complete document. </p>

</div>
</div>
<a id="ab6d9fa5a0bfe6e58c078ae842ef37452" name="ab6d9fa5a0bfe6e58c078ae842ef37452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d9fa5a0bfe6e58c078ae842ef37452">&#9670;&#160;</a></span>getTrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool getTrace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a></td>          <td class="paramname"><span class="paramname"><em>url</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a TRACE message to the server, which should return back the same message as the server received it, allowing inspection of proxy hops, etc. </p>

</div>
</div>
<a id="a6c039bd775295afd5b799d24d6a33e9a" name="a6c039bd775295afd5b799d24d6a33e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c039bd775295afd5b799d24d6a33e9a">&#9670;&#160;</a></span>getUrl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpanda3d_1_1core_1_1URLSpec.html">URLSpec</a> getUrl </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the URL that was used to retrieve the most recent document: whatever URL was last passed to get_document() or get_header(). </p>
<p>If a redirect has transparently occurred, this will return the new, redirected URL (the actual URL at which the document was located). </p>

</div>
</div>
<a id="a8d877fa4a4fd42fd3ace4def1a837cfa" name="a8d877fa4a4fd42fd3ace4def1a837cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d877fa4a4fd42fd3ace4def1a837cfa">&#9670;&#160;</a></span>getWwwRealm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str getWwwRealm </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the document failed to connect because of a 401 (Authorization required), this method will return the "realm" returned by the server in which the requested document must be authenticated. </p>
<p>This string may be presented to the user to request an associated username and password (which then should be stored in HTTPClient::set_username()). </p>

</div>
</div>
<a id="a246a4f78b2b15d0ee4da227c325cad94" name="a246a4f78b2b15d0ee4da227c325cad94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246a4f78b2b15d0ee4da227c325cad94">&#9670;&#160;</a></span>isConnectionReady()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isConnectionReady </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if a connection has been established to the named server in a previous call to connect_to() or begin_connect_to(), false otherwise. </p>

</div>
</div>
<a id="a1c4a05dc0246ea225cc3dabf39385ba1" name="a1c4a05dc0246ea225cc3dabf39385ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4a05dc0246ea225cc3dabf39385ba1">&#9670;&#160;</a></span>isDownloadComplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isDownloadComplete </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true when a download_to() or download_to_ram() has executed and the file has been fully downloaded. </p>
<p>If this still returns false after processing has completed, there was an error in transmission.</p>
<p>Note that simply testing is_download_complete() does not prove that the requested document was successfully retrieved&ndash;you might have just downloaded the "404 not found" stub (for instance) that a server would provide in response to some error condition. You should also check is_valid() to prove that the file you expected has been successfully retrieved. </p>

</div>
</div>
<a id="a5629e01ca1fed4bff5f2b69ccabae50d" name="a5629e01ca1fed4bff5f2b69ccabae50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5629e01ca1fed4bff5f2b69ccabae50d">&#9670;&#160;</a></span>isFileSizeKnown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isFileSizeKnown </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the size of the file we are currently retrieving was told us by the server and thus is reliably known, or false if the size reported by get_file_size() represents an educated guess (possibly as set by set_expected_file_size(), or as inferred from a chunked transfer encoding in progress). </p>

</div>
</div>
<a id="afe93e17ac89cd97917811068ba2af214" name="afe93e17ac89cd97917811068ba2af214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe93e17ac89cd97917811068ba2af214">&#9670;&#160;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isValid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the last-requested document was successfully retrieved and is ready to be read, false otherwise. </p>

</div>
</div>
<a id="abc29122cde69faff4d9e6e20ec0df0a7" name="abc29122cde69faff4d9e6e20ec0df0a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc29122cde69faff4d9e6e20ec0df0a7">&#9670;&#160;</a></span>openReadBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpanda3d_1_1core_1_1ISocketStream.html">ISocketStream</a> openReadBody </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a newly-allocated istream suitable for reading the body of the document. </p>
<p>This may only be called immediately after a call to get_document() or post_form(), or after a call to <a class="el" href="#a149ad6701e3e2414cb566bb414029841" title="This must be called from time to time when non-blocking I/O is in use.">run()</a> has returned false.</p>
<p>Note that, in nonblocking mode, the returned stream may report an early EOF, even before the actual end of file. When this happens, you should call stream-&gt;is_closed() to determine whether you should attempt to read some more later.</p>
<p>The user is responsible for passing the returned istream to close_read_body() later. </p>

</div>
</div>
<a id="a596585d58d68672d6b6486ff3a6e9cba" name="a596585d58d68672d6b6486ff3a6e9cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596585d58d68672d6b6486ff3a6e9cba">&#9670;&#160;</a></span>postForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool postForm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a></td>          <td class="paramname"><span class="paramname"><em>url</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>body</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Posts form data to a particular URL and retrieves the response. </p>

</div>
</div>
<a id="af97d88594ea04119fd1141785a3d2792" name="af97d88594ea04119fd1141785a3d2792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97d88594ea04119fd1141785a3d2792">&#9670;&#160;</a></span>preserveStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">preserveStatus </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Preserves the previous status code (presumably a failure) from the previous connection attempt. </p>
<p>If the subsequent connection attempt also fails, the returned status code will be the better of the previous code and the current code.</p>
<p>This can be called to daisy-chain subsequent attempts to download the same document from different servers. After all servers have been attempted, the final status code will reflect the attempt that most nearly succeeded. </p>

</div>
</div>
<a id="a4da885d2caca28faa8d5ca6f9d532fdd" name="a4da885d2caca28faa8d5ca6f9d532fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da885d2caca28faa8d5ca6f9d532fdd">&#9670;&#160;</a></span>putDocument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool putDocument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpanda3d_1_1core_1_1DocumentSpec.html">DocumentSpec</a></td>          <td class="paramname"><span class="paramname"><em>url</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>body</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uploads the indicated body to the server to replace the indicated URL, if the server allows this. </p>

</div>
</div>
<a id="a4a20559544fdf4dcb457e258dc976cf8" name="a4a20559544fdf4dcb457e258dc976cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a20559544fdf4dcb457e258dc976cf8">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops whatever file transaction is currently in progress, closes the connection, and resets to begin anew. </p>
<p>You shouldn't ever need to call this, since the channel should be able to reset itself cleanly between requests, but it is provided in case you are an especially nervous type.</p>
<p>Don't call this after every request unless you set set_persistent_connection() to false, since calling <a class="el" href="#a4a20559544fdf4dcb457e258dc976cf8" title="Stops whatever file transaction is currently in progress, closes the connection, and resets to begin ...">reset()</a> rudely closes the connection regardless of whether we have told the server we intend to keep it open or not. </p>

</div>
</div>
<a id="a149ad6701e3e2414cb566bb414029841" name="a149ad6701e3e2414cb566bb414029841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149ad6701e3e2414cb566bb414029841">&#9670;&#160;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool run </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This must be called from time to time when non-blocking I/O is in use. </p>
<p>It checks for data coming in on the socket and writes data out to the socket when possible, and does whatever processing is required towards completing the current task.</p>
<p>The return value is true if the task is still pending (and <a class="el" href="#a149ad6701e3e2414cb566bb414029841" title="This must be called from time to time when non-blocking I/O is in use.">run()</a> will need to be called again in the future), or false if the current task is complete. </p>

</div>
</div>
<a id="a6c35a92dfd817cf3ec2895fc203f2290" name="a6c35a92dfd817cf3ec2895fc203f2290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c35a92dfd817cf3ec2895fc203f2290">&#9670;&#160;</a></span>sendExtraHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sendExtraHeader </td>
          <td>(</td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies an additional key: value pair that is added into the header sent to the server with the next request. </p>
<p>This is passed along with no interpretation by the <a class="el" href="classpanda3d_1_1core_1_1HTTPChannel.html" title="A single channel of communication from an HTTPClient.">HTTPChannel</a> code. You may call this repeatedly to append multiple headers.</p>
<p>This is persistent for one request only; it must be set again for each new request. </p>

</div>
</div>
<a id="a56c723f77dea3d31767468b46d90b1fe" name="a56c723f77dea3d31767468b46d90b1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c723f77dea3d31767468b46d90b1fe">&#9670;&#160;</a></span>setAllowProxy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setAllowProxy </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allow_proxy</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If this is true (the normal case), the <a class="el" href="classpanda3d_1_1core_1_1HTTPClient.html" title="Handles contacting an HTTP server and retrieving a document.">HTTPClient</a> will be consulted for information about the proxy to be used for each connection via this <a class="el" href="classpanda3d_1_1core_1_1HTTPChannel.html" title="A single channel of communication from an HTTPClient.">HTTPChannel</a>. </p>
<p>If this has been set to false by the user, then all connections will be made directly, regardless of the proxy settings indicated on the <a class="el" href="classpanda3d_1_1core_1_1HTTPClient.html" title="Handles contacting an HTTP server and retrieving a document.">HTTPClient</a>. </p>

</div>
</div>
<a id="ac976b94be9c24bf79941b72bf095837a" name="ac976b94be9c24bf79941b72bf095837a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac976b94be9c24bf79941b72bf095837a">&#9670;&#160;</a></span>setBlockingConnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setBlockingConnect </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>blocking_connect</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If this flag is true, a socket connect will block even for nonblocking I/O calls like begin_get_document(), begin_connect_to(), etc. </p>
<p>If false, a socket connect will not block for nonblocking I/O calls, but will block for blocking I/O calls (get_document(), connect_to(), etc.).</p>
<p>Setting this true is useful when you want to use non-blocking I/O once you have established the connection, but you don't want to bother with polling for the initial connection. It's also useful when you don't particularly care about non-blocking I/O, but you need to respect timeouts like connect_timeout and http_timeout. </p>

</div>
</div>
<a id="a5a79dd23b482aa8b9174d147e745147b" name="a5a79dd23b482aa8b9174d147e745147b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a79dd23b482aa8b9174d147e745147b">&#9670;&#160;</a></span>setConnectTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setConnectTimeout </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>timeout_seconds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum length of time, in seconds, that the channel will wait before giving up on establishing a TCP connection. </p>
<p>At present, this is used only for the nonblocking interfaces (e.g. begin_get_document(), begin_connect_to()), but it is used whether set_blocking_connect() is true or false. </p>

</div>
</div>
<a id="af9596797ad071ff2ce5626aabb38ae95" name="af9596797ad071ff2ce5626aabb38ae95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9596797ad071ff2ce5626aabb38ae95">&#9670;&#160;</a></span>setContentType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setContentType </td>
          <td>(</td>
          <td class="paramtype">str</td>          <td class="paramname"><span class="paramname"><em>content_type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the Content-Type header, useful for applications that require different types of content, such as JSON. </p>

</div>
</div>
<a id="a77c98002505f9d522e172ddfcaea7636" name="a77c98002505f9d522e172ddfcaea7636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c98002505f9d522e172ddfcaea7636">&#9670;&#160;</a></span>setDownloadThrottle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setDownloadThrottle </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>download_throttle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether nonblocking downloads (via download_to_file() or download_to_ram()) will be limited so as not to use all available bandwidth. </p>
<p>If this is true, when a download has been started on this channel it will be invoked no more frequently than get_max_updates_per_second(), and the total bandwidth used by the download will be no more than get_max_bytes_per_second(). If this is false, downloads will proceed as fast as the server can send the data.</p>
<p>This only has effect on the nonblocking I/O methods like begin_get_document(), etc. The blocking methods like get_document() always use as much CPU and bandwidth as they can get. </p>

</div>
</div>
<a id="abb26631dc347dfb022ebcf8a46466573" name="abb26631dc347dfb022ebcf8a46466573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb26631dc347dfb022ebcf8a46466573">&#9670;&#160;</a></span>setExpectedFileSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setExpectedFileSize </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>file_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This may be called immediately after a call to get_document() or some related function to specify the expected size of the document we are retrieving, if we happen to know. </p>
<p>This is used as the return value to get_file_size() only in the case that the server does not tell us the actual file size. </p>

</div>
</div>
<a id="a49156e3db9020679b447d883619f4163" name="a49156e3db9020679b447d883619f4163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49156e3db9020679b447d883619f4163">&#9670;&#160;</a></span>setHttpTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setHttpTimeout </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>timeout_seconds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the maximum length of time, in seconds, that the channel will wait for the HTTP server to finish sending its response to our request. </p>
<p>The timer starts counting after the TCP connection has been established (see set_connect_timeout(), above) and the request has been sent.</p>
<p>At present, this is used only for the nonblocking interfaces (e.g. begin_get_document(), begin_connect_to()), but it is used whether set_blocking_connect() is true or false. </p>

</div>
</div>
<a id="adfaafc3e7f11c17e12fd4665f07cf65b" name="adfaafc3e7f11c17e12fd4665f07cf65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfaafc3e7f11c17e12fd4665f07cf65b">&#9670;&#160;</a></span>setIdleTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setIdleTimeout </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>idle_timeout</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the amount of time, in seconds, in which a previously-established connection is allowed to remain open and unused. </p>
<p>If a previous connection has remained unused for at least this number of seconds, it will be closed and a new connection will be opened; otherwise, the same connection will be reused for the next request (for this particular <a class="el" href="classpanda3d_1_1core_1_1HTTPChannel.html" title="A single channel of communication from an HTTPClient.">HTTPChannel</a>). </p>

</div>
</div>
<a id="a83899b253c4fc07a7ade67669516ed04" name="a83899b253c4fc07a7ade67669516ed04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83899b253c4fc07a7ade67669516ed04">&#9670;&#160;</a></span>setMaxBytesPerSecond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setMaxBytesPerSecond </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>max_bytes_per_second</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When bandwidth throttling is in effect (see set_download_throttle()), this specifies the maximum number of bytes per second that may be consumed by this channel. </p>

</div>
</div>
<a id="ad59085a5146fce383424a490bd71b13a" name="ad59085a5146fce383424a490bd71b13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59085a5146fce383424a490bd71b13a">&#9670;&#160;</a></span>setMaxUpdatesPerSecond()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setMaxUpdatesPerSecond </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>max_updates_per_second</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When bandwidth throttling is in effect (see set_download_throttle()), this specifies the maximum number of times per second that <a class="el" href="#a149ad6701e3e2414cb566bb414029841" title="This must be called from time to time when non-blocking I/O is in use.">run()</a> will attempt to do any downloading at all. </p>

</div>
</div>
<a id="ab00c438551731118217094f5e38b4383" name="ab00c438551731118217094f5e38b4383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00c438551731118217094f5e38b4383">&#9670;&#160;</a></span>setPersistentConnection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setPersistentConnection </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>persistent_connection</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether the <a class="el" href="classpanda3d_1_1core_1_1HTTPChannel.html" title="A single channel of communication from an HTTPClient.">HTTPChannel</a> should try to keep the connection to the server open and reuse that connection for multiple documents, or whether it should close the connection and open a new one for each request. </p>
<p>Set this true to keep the connections around when possible, false to recycle them.</p>
<p>It makes most sense to set this false when the <a class="el" href="classpanda3d_1_1core_1_1HTTPChannel.html" title="A single channel of communication from an HTTPClient.">HTTPChannel</a> will be used only once to retrieve a single document, true when you will be using the same <a class="el" href="classpanda3d_1_1core_1_1HTTPChannel.html" title="A single channel of communication from an HTTPClient.">HTTPChannel</a> object to retrieve multiple documents. </p>

</div>
</div>
<a id="a6fc159cc3f041ec442e1dc84d20bf926" name="a6fc159cc3f041ec442e1dc84d20bf926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc159cc3f041ec442e1dc84d20bf926">&#9670;&#160;</a></span>setProxyTunnel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setProxyTunnel </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>proxy_tunnel</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normally, a proxy is itself asked for ordinary URL's, and the proxy decides whether to hand the client a cached version of the document or to contact the server for a fresh version. </p>
<p>The proxy may also modify the headers and transfer encoding on the way.</p>
<p>If this is set to true, then instead of asking for URL's from the proxy, we will ask the proxy to open a connection to the server (for instance, on port 80); if the proxy honors this request, then we contact the server directly through this connection to retrieve the document. If the proxy does not honor the connect request, then the retrieve operation fails.</p>
<p>SSL connections (e.g. https), and connections through a Socks proxy, are always tunneled, regardless of the setting of this flag. </p>

</div>
</div>
<a id="a3dfb6dea4a2bc13ede4e5b3dd87ada9c" name="a3dfb6dea4a2bc13ede4e5b3dd87ada9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dfb6dea4a2bc13ede4e5b3dd87ada9c">&#9670;&#160;</a></span>setSkipBodySize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">setSkipBodySize </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>skip_body_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the maximum number of bytes in a received (but unwanted) body that will be skipped past, in order to reset to a new request. </p>
<p>That is, if this <a class="el" href="classpanda3d_1_1core_1_1HTTPChannel.html" title="A single channel of communication from an HTTPClient.">HTTPChannel</a> requests a file via get_document(), but does not call download_to_ram(), download_to_file(), or open_read_body(), and instead immediately requests a new file, then the <a class="el" href="classpanda3d_1_1core_1_1HTTPChannel.html" title="A single channel of communication from an HTTPClient.">HTTPChannel</a> has a choice whether to skip past the unwanted document, or to close the connection and open a new one. If the number of bytes to skip is more than this threshold, the connection will be closed; otherwise, the data will simply be read and discarded. </p>

</div>
</div>
<a id="aab5e1edb899e7b2642097e2fd641f879" name="aab5e1edb899e7b2642097e2fd641f879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5e1edb899e7b2642097e2fd641f879">&#9670;&#160;</a></span>willCloseConnection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool willCloseConnection </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the server has indicated it will close the connection after this document has been read, or false if it will remain open (and future documents may be requested on the same connection). </p>

</div>
</div>
<a id="a4256380c28989809c969a89369f31a0c" name="a4256380c28989809c969a89369f31a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4256380c28989809c969a89369f31a0c">&#9670;&#160;</a></span>writeHeaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">writeHeaders </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpanda3d_1_1core_1_1Ostream.html">Ostream</a></td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a list of all headers defined by the server to the indicated output stream. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Nov 8 2024 11:21:34 for Panda3D by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
